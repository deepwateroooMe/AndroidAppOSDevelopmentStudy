#+latex_class: cn-article
#+title: Android ActivityService相关的原理
#+author: deepwaterooo

* android内核剖析学习笔记：AMS（ActivityManagerService）内部原理和工作机制
** 一、ActivityManagerService提供的主要功能：
- （1）统一调度各应用程序的Activity
- （2）内存管理
- （3）进程管理
** 二、启动一个Activity的方式有以下几种：
- （1）在应用程序中调用startActivity启动指定的Activity
- （2）在Home程序中单击一个应用图标，启动新的Activity
- （3）按“Back”键，结束当前Activity，返回到上一个Activity
- （4）长按“Home”键，显示出当前正在运行的程序列表，从中选择一个启动
- 这四种启动方式的主体处理流程都会按照第一种启动方式运行，后面三种方式只是在前端消息处理上各有不同。
** 三、进程数据类ProcessRecord
- 该类的源代码在~\frameworks\base\services\java\com\android\server\am路径下。
- 一般情况下，一个APK文件运行时会对应一个进程，ProcessRecord用来记录一个进程中的相关信息，主要包含的变量有：
*** （1）进程文件信息：与该进程对应的APK文件的内部信息，如
    #+BEGIN_SRC csharp
final ApplicationInfo info; // all about the first app in the process
final String processName;   // name of the process
final ArrayMap<String, ProcessStats.ProcessState> pkgList 
    = new ArrayMap<String, ProcessStats.ProcessState>();   //保存进程中所有APK文件包名
    #+END_SRC 
*** （2）进程的内存状态信息：用于Linux系统的out of memory(OOM)情况的处理，当发生内存紧张时，Linux系统会根据进程的内存状态信息杀掉低优先级的进程，包括的变量有
    #+BEGIN_SRC csharp
int maxAdj;                 // Maximum OOM adjustment for this process
int curRawAdj;              // Current OOM unlimited adjustment for this process
int setRawAdj;              // Last set OOM unlimited adjustment for this process
int curAdj;                 // Current OOM adjustment for this proce
int setAdj;                 // Last set OOM adjustment for this process
    #+END_SRC 
- 变量中Adj的含义是调整值（adjustment）
*** （3）进程中包含的Activity、Provider、Service等，如下
#+BEGIN_SRC csharp
final ArrayList<ActivityRecord> activities = new ArrayList<ActivityRecord>();
final ArraySet<ServiceRecord> services = new ArraySet<ServiceRecord>();
final ArraySet<ServiceRecord> executingServices = new ArraySet<ServiceRecord>();
final ArraySet<ConnectionRecord> connections = new ArraySet<ConnectionRecord>();
final ArraySet<ReceiverList> receivers = new ArraySet<ReceiverList>();
final ArrayMap<String, ContentProviderRecord> pubProviders = new ArrayMap<String,             ContentProviderRecord>();
final ArrayList<ContentProviderConnection> conProviders = new ArrayList<ContentProviderConnection>();
#+END_SRC 
** 四、ActivityRecord数据类（Android 2.3以前版本叫HistoryRecord类）
- ActivityManagerService使用ActivityRecord数据类来保存每个Activity的信息，ActivityRecord类基于IApplicationToken.Stub类，也是一个Binder,所以可以被IPC调用。
- 主要包含的变量有：
*** （1）环境信息：Activity的工作环境，比如进程名称、文件路径、数据路径、图标、主题等，这些信息一般是固定的，比如以下变量
#+BEGIN_SRC csharp
final String packageName; // the package implementing intent's component
final String processName; // process where this component wants to run
final String baseDir;   // where activity source (resources etc) located
final String resDir;   // where public activity source (public resources etc) located
final String dataDir;   // where activity data should go
int theme;              // resource identifier of activity's theme.
int realTheme;          // actual theme resource we will use, never 0.
#+END_SRC 
*** （2）运行状态数据信息：如idle、stop、finishing等，一般为boolean类型，如下
#+BEGIN_SRC csharp
boolean haveState;      // have we gotten the last activity state?
boolean stopped;        // is activity pause finished?
boolean delayedResume;  // not yet resumed because of stopped app switches?
boolean finishing;      // activity in pending finish list?
boolean configDestroy;  // need to destroy due to config change?
#+END_SRC 
** 五、TaskRecord类
- ActivityManagerService中使用任务的概念来确保Activity启动和退出的顺序。
- TaskRecord中的几个重要变量如下：
#+BEGIN_SRC csharp
final int taskId;       // 每个任务的标识.
Intent intent;          // 创建该任务时对应的intent
int numActivities;   //该任务中的Activity数目
final ArrayList<ActivityRecord> mActivities = new ArrayList<ActivityRecord>();  //按照出现的先后顺序列出该任务中的所有Activity
#+END_SRC 
** 六、ActivityManagerService中一些重要的与调度相关的变量
- （1）记录最近启动的Activity，如果RAM容量较小，则记录的最大值为10个，否则为20个，超过该值后，Ams会舍弃最早记录的Activity
#+BEGIN_SRC csharp
static final int MAX_RECENT_TASKS = ActivityManager.isLowRamDeviceStatic() ? 10 : 20;
#+END_SRC 
- （2）当Ams通知应用程序启动（Launch）某个Activity时，如果超过10s，Ams就会放弃
#+BEGIN_SRC csharp
static final int PROC_START_TIMEOUT = 10*1000;
#+END_SRC 
- （3）当Ams启动某个客户进程后，客户进程必须在10s之内报告Ams自己已经启动，否则Ams会认为指定的客户进程不存在
#+BEGIN_SRC csharp
static final int PROC_START_TIMEOUT = 10*1000;
#+END_SRC 
- （4）等待序列：
  - 当Ams内部还没有准备好时，如果客户进程请求启动某个Activity，那么会被暂时保存到该变量中，
#+BEGIN_SRC csharp
final ArrayList<PendingActivityLaunch> mPendingActivityLaunches
    = new ArrayList<PendingActivityLaunch>();
#+END_SRC 
- （5）优先启动，其次再停止。进程A1包含两个Activity，启动顺序为A1->A2，当用户请求启动A2时，如果A1正在运行，Ams会先暂停A1，然后启动A2，当A2启动后再停止A1。
#+BEGIN_SRC csharp
private final ArrayList<TaskRecord> mRecentTasks = new ArrayList<TaskRecord>();
#+END_SRC 
** 七、startActivity()的流程
- 当用户单击某个应用图标后，执行程序会在该图标的onClick()事件中调用startActivity()方法，该方法会调用startActivityForResult()，在这个方法内部会调用Instrumentation对象的executeStartActivity()方法，每个Activity内部都有一个Instrumentation对象的引用，它就是一个管家，ActivityThread要创建或者暂停某个Activity都是通过它实现的。
- 流程图如下所示：
  
[[./pic/activityService_20220828_103648.png]]

* ActivityManagerService源码分析
- AMS是Android系统服务中很重要的一个，他负责四大组件的启动、切换、调度、生命周期的管理等等，接下来我们根据AMS的启动来分析AMS的源码
- AMS是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。
- AMS比较复杂，本章将带领读者按五条不同的线来分析它：
  - 1.       第一条线：同其他服务一样，将分析SystemServer中AMS的调用轨迹。
  - 2.       第二条线：以am命令启动一个Activity为例，分析应用进程的创建、Activity的启动，以及它们和AMS之间的交互等知识。
  - 3.       第三条线和第四条线：分别以Broadcast和Service为例，分析AMS中Broadcast和Service的相关处理流程。
  - 4.       第五条线：以一个Crash的应用进程为出发点，分析AMS如何打理该应用进程的身后事。
- AMS的家族图谱：
  
[[./pic/activityService_20220828_152742.png]]
- AMS由ActivityManagerNative（以后简称AMN）类派生，并实现Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口。而AMN由Binder派生，实现了IActivityManager接口。
- 客户端使用ActivityManager类。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。

** SystemServer启动AMS
- ActivityManagerService是在SystemServer.java中启动并注册的：
#+BEGIN_SRC csharp
private void startBootstrapServices() {

    // 启动AMS，见小节2.1
    mActivityManagerService = mSystemServiceManager.startService(
        ActivityManagerService.Lifecycle.class).getService();

    // 设置AMS
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);

    // 安装App安装器
    mActivityManagerService.setInstaller(installer);

    // 电源管理已经开启，在AMS中初始化PM，见小节3
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "InitPowerManagement");
    mActivityManagerService.initPowerManagement();
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);

    // 设置应用实例，在系统进程开始的时候，见小节4
    mActivityManagerService.setSystemProcess();
}
#+END_SRC 
- 看源码可以看到，startBootstrapServices中启动并注册了很多其他的服务，比如：PowerManagerService，DisplayManagerService，LightsService，PackageManagerService，UserManagerService，SensorService(native)，这写服务彼此之间有依赖，所以都放在startBootstrapServices方法里面
** 注册并启动
*** startService: 文件：SystemServiceManager.java
#+BEGIN_SRC csharp
public <T extends SystemService> T startService(Class<T> serviceClass) {
    try {
        final String name = serviceClass.getName();
        Slog.i(TAG, "Starting " + name);

        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartService " + name);
        // 创建服务:这个服务的类必须是SystemService的子类，于是我们需要传入带有ActivityManagerService的Lifecycle 
        if (!SystemService.class.isAssignableFrom(serviceClass)) {
            throw new RuntimeException("Failed to create " + name
                                       + ": service must extend " + SystemService.class.getName());
        }
        final T service;
        try {
            Constructor<T> constructor = serviceClass.getConstructor(Context.class);
            service = constructor.newInstance(mContext);
        } catch (InstantiationException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service could not be instantiated", ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service must have a public constructor with a Context argument", ex);
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service must have a public constructor with a Context argument", ex);
        } catch (InvocationTargetException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service constructor threw an exception", ex);
        }
        // 注册
        mServices.add(service);
        // 开始服务
        try {
            service.onStart();
        } catch (RuntimeException ex) {
            throw new RuntimeException("Failed to start service " + name
                                       + ": onStart threw an exception", ex);
        }
        return service;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
}
#+END_SRC 
- 可以看出这方法的作用是创建并且开始一个服务，但是这个服务的类必须是SystemService的子类，于是我们需要传入带有ActivityManagerService的Lifecycle
*** Lifecycle: 文件：SystemServiceManager.java
#+BEGIN_SRC csharp
public static final class Lifecycle extends SystemService {
    private final ActivityManagerService mService;

    public Lifecycle(Context context) {
        super(context);
        // 构建一个新的AMS，见小节2.3
        mService = new ActivityManagerService(context);
    }
    @Override public void onStart() {
        // 开始服务，2.1中的service.onStart()调用的就是它，见小节2.4
        mService.start();
    }
    public ActivityManagerService getService() {
        return mService;
    }
}
#+END_SRC 
- 可以看出Lifecycle是继承SystemService的，并且在构造里构建了AMS，接下来我们来看看AMS的构建函数
*** AMS的构建函数
- 这个方法会在main thread中被唤醒，但是它需要通过各个handers和其他thread通信，所以要注意明确looper。该构造函数，里面是初始化一些变量，及创建了一些线程
#+BEGIN_SRC csharp
public ActivityManagerService(Context systemContext) {
    mContext = systemContext;
    mFactoryTest = FactoryTest.getMode();

    mSystemThread = ActivityThread.currentActivityThread();
    Slog.i(TAG, "Memory class: " + ActivityManager.staticGetMemoryClass());

    // 创建一个mHandlerThread线程，默认名是：ActivityManager，异步线程 [ServiceThread 与 HandlerThread 有什么不同 ？]
    mHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false /*allowIo*/);
    mHandlerThread.start();
    // 创建一个基于ActivityManager线程的Handler
    mHandler = new MainHandler(mHandlerThread.getLooper());

    // 创建一个UiHandler线程，是异步线程吗？
    mUiHandler = new UiHandler();

    // 用单例的方式创建一个名叫ActivityManager:kill的线程，并且创建一个killHandler
    if (sKillHandler == null) {
        sKillThread = new ServiceThread(TAG + ":kill",
                                        android.os.Process.THREAD_PRIORITY_BACKGROUND, true /* allowIo */);
        sKillThread.start();
        // 用于杀死进程
        sKillHandler = new KillHandler(sKillThread.getLooper());
    }

    // 构建一个可以延时10秒的前台广播队列
    mFgBroadcastQueue = new BroadcastQueue(this, mHandler,
                                           "foreground", BROADCAST_FG_TIMEOUT, false);
    // 构建一个可以延时60秒的普通广播队列(一定全都是后台广播吗？)
    mBgBroadcastQueue = new BroadcastQueue(this, mHandler,
                                           "background", BROADCAST_BG_TIMEOUT, true);
    mBroadcastQueues[0] = mFgBroadcastQueue; // 不故道这个数组的定义是在哪里，反正长度 >= 2
    mBroadcastQueues[1] = mBgBroadcastQueue;
    
    mServices = new ActiveServices(this);
    mProviderMap = new ProviderMap(this);
    mAppErrors = new AppErrors(mContext, this);

    // 新建一个data/system目录
    File dataDir = Environment.getDataDirectory();
    File systemDir = new File(dataDir, "system");
    systemDir.mkdirs();

    // 创建一个BatteryStatsService类
    mBatteryStatsService = new BatteryStatsService(systemDir, mHandler);
    // 把最新的数据写入硬盘
    mBatteryStatsService.scheduleWriteToDisk();
    mOnBattery = DEBUG_POWER ? true
        : mBatteryStatsService.getActiveStatistics().getIsOnBattery();
    mBatteryStatsService.getActiveStatistics().setCallback(this);

    // 创建进程统计服务类，并新建一个data/system/procstats目录
    mProcessStats = new ProcessStatsService(this, new File(systemDir, "procstats"));
    // 创建一个应用权限检查类，新建一个data/system/appops.xml文件，并注册对应的回调接口
    mAppOpsService = new AppOpsService(new File(systemDir, "appops.xml"), mHandler);
    mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null,
                                     new IAppOpsCallback.Stub() {
                                         @Override public void opChanged(int op, int uid, String packageName) {
                                             if (op == AppOpsManager.OP_RUN_IN_BACKGROUND && packageName != null) {
                                                 if (mAppOpsService.checkOperation(op, uid, packageName)
                                                     != AppOpsManager.MODE_ALLOWED) {
                                                     runInBackgroundDisabled(uid);
                                                 }
                                             }
                                         }
                                     });
    mGrantFile = new AtomicFile(new File(systemDir, "urigrants.xml"));

    // 创建多用户控制器，user 0是第一个，同时也是唯一开机过程中运行的用户
    mUserController = new UserController(this);

    // 获取OpenGL版本，如果没有找到，则默认为0
    GL_ES_VERSION = SystemProperties.getInt("ro.opengles.version",
                                            ConfigurationInfo.GL_ES_VERSION_UNDEFINED);

    mTrackingAssociations = "1".equals(SystemProperties.get("debug.track-associations"));
    // 设置系统的一些默认配置信息
    mConfiguration.setToDefaults();
    mConfiguration.setLocales(LocaleList.getDefault());
    mConfigurationSeq = mConfiguration.seq = 1;

    // 初始化进程CPU跟踪器
    mProcessCpuTracker.init();
    // 解析/data/system/packages-compat.xml文件，当设备屏幕大小不满足APK所需要的大小，
    // 则从packages-compat.xml都去尺寸，用兼容的方式运行
    mCompatModePackages = new CompatModePackages(this, systemDir, mHandler);

    // 根据AMS传入规则，过滤一些Intent
    mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), mHandler);

    // 用来管理Activity栈: 应试就是当系统有多个任务栈时，它们多任务栈的管理者，用于管理系统下存在的多个任务栈
    mStackSupervisor = new ActivityStackSupervisor(this);
    // 解释怎样启动Activity
    mActivityStarter = new ActivityStarter(this, mStackSupervisor);
    // 管理最近任务列表
    mRecentTasks = new RecentTasks(this, mStackSupervisor);

    // 创建一个统计 进程使用CPU情况 的线程，名叫CpuTracker
    mProcessCpuThread = new Thread("CpuTracker") {
        @Override
        public void run() {
            while (true) {
                try {
                    try {
                        synchronized(this) {
                            final long now = SystemClock.uptimeMillis();
                            long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;
                            long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;
                            //Slog.i(TAG, "Cpu delay=" + nextCpuDelay
                            //        + ", write delay=" + nextWriteDelay);
                            if (nextWriteDelay < nextCpuDelay) 
                                nextCpuDelay = nextWriteDelay;
                            if (nextCpuDelay > 0) {
                                mProcessCpuMutexFree.set(true);
                                this.wait(nextCpuDelay);
                            }
                        }
                    } catch (InterruptedException e) {
                    }
                    updateCpuStatsNow();
                } catch (Exception e) {
                    Slog.e(TAG, "Unexpected exception collecting process stats", e);
                }
            }
        }
    };
    // watchdog添加对AMS的监控
    Watchdog.getInstance().addMonitor(this);
    Watchdog.getInstance().addThread(mHandler);
}
#+END_SRC 
- 这个方法会在main thread中被唤醒，但是它需要通过各个handers和其他thread通信，所以要注意明确looper。该构造函数，里面是初始化一些变量，及创建了一些线程，大部分我都进行了注释。
*** start: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
private void start() {
    // 移除所有的进程组
    Process.removeAllProcessGroups();
    // 开始监控进程的CPU使用情况
    mProcessCpuThread.start();
    // 注册电池统计服务
    mBatteryStatsService.publish(mContext);
    // 注册应用权限检测服务
    mAppOpsService.publish(mContext);
    Slog.d("AppOps", "AppOpsService published");
    // 注册LocalService服务
    LocalServices.addService(ActivityManagerInternal.class, new LocalService());
}
#+END_SRC 
- 启动ProcessCpuThread，注册电池统计服务，应用权限检测服务和LocalService，其中LocalService继承了ActivityManagerInternal。
- 小结：创建AMS，启动AMS
** 初始化PM: initPowerManagement: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
public void initPowerManagement() {
    // Activity堆栈管理器和电池统计服务初始化PM
    mStackSupervisor.initPowerManagement();
    mBatteryStatsService.initPowerManagement();
    mLocalPowerManager = LocalServices.getService(PowerManagerInternal.class);
    PowerManager pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "*voice*");
    // 该唤醒锁为不计数锁，即无论acquire()多少次，一次release()就可以解锁
    mVoiceWakeLock.setReferenceCounted(false);
}
#+END_SRC 
- 小结：这主要是在AMS中初始化PM
** 设置应用实例
***  setSystemProcess: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
public void setSystemProcess() {
    try {
        // 以下都是想ServiceManager注册服务
        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); // 注册AMS自己
        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); // 注册进程统计服务
        ServiceManager.addService("meminfo", new MemBinder(this)); // 注册内存信息的服务
        ServiceManager.addService("gfxinfo", new GraphicsBinder(this)); // 注册输出渲染信息的服务
        ServiceManager.addService("dbinfo", new DbBinder(this)); // 注册输出数据库信息的服务
        // MONITOR_CPU_USAGE默认为true
        if (MONITOR_CPU_USAGE) {
            ServiceManager.addService("cpuinfo", new CpuBinder(this)); // 输出进程使用CPU的情况
        }
        ServiceManager.addService("permission", new PermissionController(this)); // 注册权限管理
        ServiceManager.addService("processinfo", new ProcessInfoService(this)); // 注册进程信息

        // 查询名为android的应用信息
        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(
            "android", STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);
        // 调用installSystemApplicationInfo ，见小节4.2
        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());

        synchronized (this) {
            // 创建一个ProcessRecord对象 ，见小节4.5
            ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
            app.persistent = true;
            app.pid = MY_PID;
            app.maxAdj = ProcessList.SYSTEM_ADJ;
            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.put(app.pid, app);
            }
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(
            "Unable to find android system package", e);
    }
}
#+END_SRC 
*** installSystemApplicationInfo: 文件：ActivityThread.java
#+BEGIN_SRC csharp
public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) {
    synchronized (this) {
        // 看SystemService中创建的ContextIml的installSystemApplicationInfo，见小节4.3
        getSystemContext().installSystemApplicationInfo(info, classLoader);
        // give ourselves a default profiler
        mProfiler = new Profiler();
    }
}
#+END_SRC 
*** ContextIml.installSystemApplicationInfo:文件：ContextImpl.java
#+BEGIN_SRC csharp
void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) {
    // 调用的是LoadeApk里面的installSystemApplicationInfo，见小节4.4
    mPackageInfo.installSystemApplicationInfo(info, classLoader);
}
#+END_SRC 
*** LoadeApk.installSystemApplicationInfo: 文件：LoadeApk.java
#+BEGIN_SRC csharp
void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) {
    // 断言只有packageName为android才能使用
    assert info.packageName.equals("android");
    mApplicationInfo = info;
    mClassLoader = classLoader;
}
#+END_SRC 
- 将ApplicationInfo加入到LoadeApk中，因为SystemService创建LoadeApk时，PKMS并没有完成对手机中文件的解析
*** AMS进程管理: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
synchronized (this) {
    // 调用进程管理函数，见4.6
    ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
    app.persistent = true;
    app.pid = MY_PID;
    app.maxAdj = ProcessList.SYSTEM_ADJ;
    // 将SystemServer对应的ApplicationThread保存到ProcessRecord中
    app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
    synchronized (mPidsSelfLocked) {
        // 根据ProcessRecord的pid，将ProcessRecord存在mPidsSelfLocked中
        mPidsSelfLocked.put(app.pid, app);
    }
    updateLruProcessLocked(app, false, null);
    updateOomAdjLocked();
}
#+END_SRC 
*** newProcessRecordLocked: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess,
        boolean isolated, int isolatedUid) {
    String proc = customProcess != null ? customProcess : info.processName;
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    final int userId = UserHandle.getUserId(info.uid);
    int uid = info.uid;
    // isolated为false
    if (isolated) {
            }
    // 创建一个进程记录对象，见小节4.7
    final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
    // 判断是否为常驻的进程
    if (!mBooted && !mBooting
            && userId == UserHandle.USER_SYSTEM
            && (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK) {
        r.persistent = true;
    }
    // 将ProcessRecord保存在AMS里的mProcessNames里
    addProcessNameLocked(r);
    return r;
}
#+END_SRC 
*** ProcessRecord: 文件：ProcessRecord.java
#+BEGIN_SRC csharp
ProcessRecord(BatteryStatsImpl _batteryStats, ApplicationInfo _info,
        String _processName, int _uid) {
    mBatteryStats = _batteryStats;
    info = _info;
    isolated = _info.uid != _uid;
    uid = _uid;
    userId = UserHandle.getUserId(_uid);
    processName = _processName;
    pkgList.put(_info.packageName, new ProcessStats.ProcessStateHolder(_info.versionCode));
    maxAdj = ProcessList.UNKNOWN_ADJ;
    curRawAdj = setRawAdj = ProcessList.INVALID_ADJ;
    curAdj = setAdj = verifiedAdj = ProcessList.INVALID_ADJ;
    persistent = false;
    removed = false;
    lastStateTime = lastPssTime = nextPssTime = SystemClock.uptimeMillis();
}
#+END_SRC 
- 这主要是保存一些ProcessRecord里面的属性。
- 小结：
  - 第四节的主要作用就是将一些服务注册到ServiceManger中，包括AMS自己；然后将framework-res-.apk中applicationInfo信息加入到SystemServeice生成的LoadedApk中，同时构建SystemService对应的ProcessRecord，最后通过addProcessNameLocked(r)来把SystemService加入AMS的管理中来。
* 这一小部分，感觉和自己所掌握的远程服务绑定基础，讲解得很透彻
- AMS(ActivityManagerService)是贯穿Android系统组件的核心服务，负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作。因此想要了解Android的内部工作机制，就必须先了解�AMS的工作原理。在本文中，我将尽可能用通俗的语言去描述AMS涉及到的知识点帮助大家理解。
- 先梳理一下这个远程服务它所管理纪录着的几样对它来说狠重要的内容类别： 
- AMS提供了一个ArrayList mHistory来管理所有的activity，activity在AMS中的形式是ActivityRecord，task在AMS中的形式为TaskRecord，进程在AMS中的管理形式为ProcessRecord。如下图所示
  
[[./pic/activityService_20220828_165105.png]]
  -     从图中我们可以看出如下几点规则：
  -     1. 所有的ActivityRecord会被存储在mHistory管理；
  -     2. 每个ActivityRecord会对应到一个TaskRecord，并且有着相同TaskRecord的ActivityRecord在mHistory中会处在连续的位置；
  -     3. 同一个TaskRecord的Activity可能分别处于不同的进程中，每个Activity所处的进程跟task没有关系；
  -     因此，在分析Activity管理之前，先了解一下这个规则。
** AMS的内部实现
*** AMS原理模型
**** 1. ActivityManager
     #+BEGIN_SRC text
/frameworks/base/core/java/android/app/ActivityManager.java
     #+END_SRC 
- *ActivityManager* 是 *客户端* 用来 *管理系统中正在运行的所有Activity包括Task、Memory、Service等信息的工具* 。但是 *这些信息的维护工作却不是又ActivityManager负责的。在ActivityManager中有大量的get()方法，那么也就说明了他只是提供信息给AMS，由AMS去完成交互和调度工作。*
**** 2. AMS
     #+BEGIN_SRC text
/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
     #+END_SRC 
- AMS是作为 *管理Android系统组件的核心服务* ，他在 *SystemServer执行run()方法的时候被创建，并运行在独立的进程中* 。具体来说就是 *SystemServer管理着Android中所有的系统服务，这些系统服务的生命周期回调都由SystemServer去调度负责。*
#+BEGIN_SRC csharp
private void startBootstrapServices() {
    Installer installer = mSystemServiceManager.startService(Installer.class);

    // Activity manager runs the show.
    mActivityManagerService = mSystemServiceManager.startService(
            ActivityManagerService.Lifecycle.class).getService();
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    mActivityManagerService.setInstaller(installer);
}
#+END_SRC 
- 在 *SystemServer调用run()方法中开启必要的系统服务，并将这些服务注册和添加到管理列表中，并执行这些服务在进程中的生命周期* 。ActivityManagerService作为一个重要的核心服务就是在这里被初始成功的。
** AMS与ActivityManager的通信实现
   - 我们知道 *AMS和ActivityManager之间通信需要利用Binder来完成(跨进程远程服务绑定)* ，那么我们接下来分析一下这个通信机制是如何实现的。
- *ActivityManagerNative(AMN)中实现的代码是运行在Android应用程序的进程空间内，可直接使用的对象，Intent会由应用程序通过这个类将方法对应的Binder命令发送出去* 。
- 那么上面这一句话，是否可以理解为，是AWS在安卓应用层的客户端呢？在一个安卓系统中，会有几个这样的客户端，还是唯一的呢？
- ActivityManagerNative(AMN)是一个抽象的类，他包含了如下特点：
  - （1）继承Binder类
      - （2）实现IActivityManager接口
- 由于 *继承了Binder类，他就拥有了远程通信的条件。*
- *实现了IActivityManager接口，他能够得到ActivityManager管理关于内存、任务等内部信息* 。那么AMS作为AMN的子类也就自然享有了这些特性。
- 我们再回过头来看看 *ActivityManager中的方法是如何被调用的* ，举个栗子：
   #+BEGIN_SRC csharp
public List<ActivityManager.AppTask> getAppTasks() {
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) { // <<<<<<<<<< 
        throw e.rethrowFromSystemServer();
    }
// 上面可以得到 appTasks值，再怎么稍微转化一下成为tasks, 并返回
    return tasks;
}
   #+END_SRC 
- 我们在代码中发现，类似的get()方法的调用逻辑都是 *先通过ActivityManagerNative.getDefault()来获得ActivityManager的代理接口对象* 。getDefault()到底做了什么？
#+BEGIN_SRC csharp
/**
 * Retrieve the system's default/global activity manager.
 */
static public IActivityManager getDefault() {
    return gDefault.get();
}
private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {
    protected IActivityManager create() {
        IBinder b = ServiceManager.getService("activity");
        if (false) {
            Log.v("ActivityManager", "default service binder = " + b);
        }
        IActivityManager am = asInterface(b);
        if (false) {
            Log.v("ActivityManager", "default service = " + am);
        }
        return am;
    }
};
#+END_SRC 
- *ServiceManager是系统提供的服务管理类，所有的Service都通过他被注册和管理* ，并且 *通过getService()方法能够得到ActivityManager与AMS的远程通信Binder对象。*
- 在模块化设计里，前两天刚学习的BinderPool类通过管理所有多个模块化的远程服务的IBinder来对这些远程服务绑定统一管理，感觉很类似
#+BEGIN_SRC csharp
/**
 * Cast a Binder object into an activity manager interface, generating
 * a proxy if needed.
 */
static public IActivityManager asInterface(IBinder obj) {
    if (obj == null) {
        return null;
    }
    IActivityManager in =
        (IActivityManager)obj.queryLocalInterface(descriptor); // <<<<<<<<<< 
    if (in != null) {
        return in;
    }
    return new ActivityManagerProxy(obj); // <<<<<<<<<< 
}
#+END_SRC 
    - *得到了AMS的Binder对象之后，也就相当于拿到了与ActivityManager远程通信的许可证(句柄，接下来就可以调用其所定义的远程方法了)* 。接着， *在asInterface()这个方法中，这个许可证的使用权利被移交给了ActivityManagerProxy，那么ActivityManagerProxy就成为了ActivityManager与AMS远程通信的代理。*
- *ActivityManagerProxy也实现了IActivityManager接口* 。 *当客户端（ActivityManager）发起向服务端（AMS）的远程请求时，客户端提供的数据参数信息被封装打包，然后由ActivityManager的远程通信binder对象通过transact()方法把数据提交，然后再把数据写出返回给binder对象。*
#+BEGIN_SRC csharp
public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,
                         String resolvedType, IBinder resultTo, String resultWho, int requestCode,
                         int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(callingPackage);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo);
    data.writeString(resultWho);
    data.writeInt(requestCode);
    data.writeInt(startFlags);
    if (profilerInfo != null) {
        data.writeInt(1);
        profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
    } else {
        data.writeInt(0);
    }
    if (options != null) {
        data.writeInt(1);
        options.writeToParcel(data, 0);
    } else {
        data.writeInt(0);
    }
    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
#+END_SRC 
- 通过这种方式，AMS在自己的进程中就能获得ActivityManager进程发来的数据信息，从而完成对于Android系统组件生命周期的调度工作。
- https://blog.csdn.net/yueliangniao1/article/details/7227165?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-7227165-blog-8891414.topnsimilarv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-7227165-blog-8891414.topnsimilarv1&utm_relevant_index=10 上面这个讲到了活动启动模式以及任务栈和活动在不同栈中的迁移，感觉讲到了很多细节，明天早上再仔细看一遍
- Windows上的截图是一个被我放了很久的bug,没能安排好时间占用了早上最宝贵的时间来修改，有点儿可惜，但过程中在需要的时候一定能够解决自己的应用便利需要，并解决过程中所遇到的一切问题，包括用键的一再精简与优化，snipaste截图截出的图过浅等问题，还是很开心的。因为使用powershell来拿到Windows系统的剪贴板，可能具备wsl ubuntu emacs中使用的能力，但是Ubuntu中暂时保留一个简炼启动快的版本，暂时不再配置
- 晚上会动动笔，写或总结一些基础算法题；希望早上或白天的时间都能够用来深入学习安卓系统
* PackageManagerService
- 它是Android系统中最常用的服务之一。它负责系统中Package的管理，应用程序的安装、卸载、信息查询等。
- 它的一家老小：
      
[[./pic/activityService_20220828_151856.png]]
- 分析上图：
  - 1.IPackageManager接口类中定义了服务端和客户端通信的业务函数，还定义了内部类Stub，该类从Binder派生并实现了IPackageManager接口。
  - 2.PackageManagerService继承自IPackageManager.Stub类，由于Stub类从Binder派生，因此 *PackageManagerService将作为服务端参与Binder通信。*
  - 3.Stub类中定义了一个内部类Proxy，该类有一个IBinder类型（实际类型为BinderProxy）的成员变量mRemote， *mRemote用于和服务端PackageManagerService通信。*
  - 4.IPackageManager接口类中定义了许多业务函数，但是出于安全等方面的考虑，Android对外（即SDK）提供的只是一个子集，该子集被封装在抽象类PackageManager中。客户端一般通过Context的getPackageManager函数返回一个类型为PackageManager的对象，该对象的实际类型是PackageManager的子类ApplicationPackageManager。这种基于接口编程的方式，虽然极大降低了模块之间的耦合性，却给代码分析带来了不小的麻烦。
  - 5.ApplicationPackageManager类继承自PackageManager类。它并没有直接参与Binder通信，而是通过mPM成员变量指向一个IPackageManager.Stub.Proxy类型的对象。
- PKMS构造函数的主要功能是，扫描Android系统中几个目标文件夹中的APK，从而建立合适的数据结构以管理诸如Package信息、四大组件信息、权限信息等各种信息。抽象地看，PKMS像一个加工厂，它 *解析实际的物理文件（APK文件）以生成符合自己要求的产品。*
** PKMS工作流程
   
[[./pic/activityService_20220828_151939.png]]
- PKMS构造函数的工作流程大体可分三个阶段：
  - ·  扫描目标文件夹之前的准备工作。
  - ·  扫描目标文件夹。
  - ·  扫描之后的工作。
- 该函数涉及到的知识点较多，代码段也较长，因此我们将通过分段讨论的方法，集中解决相关的重点问题。
** 扫描目标文件夹之前的准备工作
*** 设置setting
- 进入PKMS构造函数，就会遇到第一个较为复杂的数据结构Setting及它的addSharedUserLPw函数。Setting的作用是管理Android系统运行过程中的一些设置信息，包括：字符串“android.uid.system“，UID（用户ID，），用于标识系统Package的FLAG_SYSTEM标志。
*** 扫描文件夹并解析xml文件
- 创建一个Installer对象，同时并解析对应的xml文件。包括：权限，包信息等。
- PKMS将扫描以下几个目录。
  - 1. */system/frameworks* ：该目录中的文件都是系统库，例如framework.jar、services.jar、framework-res.apk。不过scanDirLI只扫描APK文件，所以framework-res.apk是该目录中唯一“受宠”的文件。
  - 2. */system/app* ：该目录下全是默认的系统应用，例如Browser.apk、SettingsProvider.apk等。
  - 3. */vendor/app* ：该目录中的文件由厂商提供，即厂商特定的APK文件，不过目前市面上的厂商都把自己的应用放在 */system/app* 目录下。
- 下面总结一下Package扫描的流程:
  - scanDirLI用于对指定目录下的APK文件进行扫描。
  - 扫描完APK文件后，Package的私有财产就充公了。PKMS提供了好几个重要数据结构来保存这些财产：
    
[[./pic/activityService_20220828_152005.png]]
*** 构造函数分析之扫尾工作
- 这部分任务比较简单，就是将第二阶段收集的信息再集中整理一次，比如汇总并更新和Permission相关的信息，将信息写到package.xml、package.list及package-stopped.xml文件中。
** PKM的install
- 故事从adbinstall开始。
*** adb install分析
- 找到apk的目录位置，把相关信息发送给指定的Verification程序（另外一个APK），由它对要安装的APK进行检查（Verify）。
- 然后开始调用pm_command开始后续工作。
*** 调用pm_command进行安装
- 在编译system.image时，Android.mk中会将该脚本复制到system/bin目录下。从pm脚本的内容来看，它就是通过app_process执行pm.jar包的main函数。app_process是一个Native进程，它通过创建虚拟机启动了Zygote，从而转变为一个Java进程。实际上，app_process还可以通过类似的方法（即先创建Dalvik虚拟机，然后执行某个类的main函数）来转变成其他Java程序。
- Pm解析参数后，最终通过PKMS的Binder客户端调用 *installPackageWithVerification* 以完成后续的安装工作。
- installPackageWithVerification函数倒是蛮清闲，检查下权限，然后简简单单创建几个对象，发送INIT_COPY消息给mHandler，就甩手退出了。
- 在mHandler中APK的安装居然需要使用另外一个APK提供的服务，该服务就是DefaultContainerService，由DefaultCotainerService.apk提供。
- 相关类的一家子：
  
[[./pic/activityService_20220828_152141.png]]
- HandlerParams和InstallArgs均为抽象类。
- *HandlerParams有三个子类，分别是InstallParams、MoveParams和MeasureParams* 。其中，InstallParams用于处理APK的安装，MoveParams用于处理某个已安装APK的搬家请求（例如从内部存储移动到SD卡上），MeasureParams用于查询某个已安装的APK占据存储空间的大小（例如在设置程序中得到的某个APK使用的缓存文件的大小）。
-  对于 *InstallParams* 来说，它 *还有两个伴儿，即InstallArgs的派生类FileInstallArgs和SdInstallArgs* 。其中，FileInstallArgs针对的是安装在内部存储的APK，而SdInstallArgs针对的是那些安装在SD卡上的APK。
- 在mhandler中处理请求：
  - 1.调用DCS的getMinimalPackageInfo函数，将得到一个PackageLite对象，该对象是一个轻量级的用于描述APK的结构（相比PackageParser.Package来说）。在这段代码逻辑中，主要想取得其recommendedInstallLocation的值。此值表示该APK推荐的安装路径。
    - 具体步骤：通过用户在Settings数据库中设置的安装位置。检查外部存储或内部存储是否有足够空间。
  - 2.调用installLocationPolicy检查推荐的安装路径。例如系统Package不允许安装在SD卡上。
  - 3.createInstallArgs将根据安装位置创建不同的InstallArgs。如果是内部存储，则返回FileInstallArgs，否则为SdInstallArgs。
  - 4.在正式安装前，应先对该APK进行必要的检查。
  - 5.调用InstallArgs的copyApk。
- 调用PKMS的installPackageLI函数进行APK安装，该函数内部将调用InstallArgs的doRename对临时文件进行改名。另外，还需要扫描此APK文件。
- 该APK已经安装完成（不论失败还是成功），继续向mHandler抛送一个 *POST_INSTALL* 消息，该消息携带一个token，通过它可从mRunningInstalls数组中取得一个PostInstallData对象
- 在接收到POST_INSTALL消息之后，发送 *PACKAGE_ADDED* 广播。
*** APK 安装流程总结
- APK的安装流程竟然如此复杂，其目的无非是 *让APK中的私人财产公有化。*
  
[[./pic/activityService_20220828_152408.png]]
- 1.安装APK到内部存储空间这一工作流程涉及的主要对象包括：PKMS、DCS、InstallParams和FileInstallArgs。
- 2.此工作流程中每个对象涉及到的关键函数。
- 3.对象之间的调用通过虚线表达，调用顺序通过①②③等标明。

* ActivityManagerService: 今天早上再读，才觉得这篇讲得深入又浅显易懂，赶快收藏
- AMS是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。
- AMS比较复杂，本章将带领读者按五条不同的线来分析它：
  - 1.第一条线：同其他服务一样，将分析SystemServer中AMS的调用轨迹。
  - 2.第二条线：以am命令启动一个Activity为例，分析应用进程的创建、Activity的启动，以及它们和AMS之间的交互等知识。
  - 3.第三条线和第四条线：分别以Broadcast和Service为例，分析AMS中Broadcast和Service的相关处理流程。
  - 4.第五条线：以一个Crash的应用进程为出发点，分析AMS如何打理该应用进程的身后事。
** AMS的家族图谱：
   
[[./pic/activityService_20220829_081607.png]]
- AMS由ActivityManagerNative（以后简称AMN）类派生，并实现Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口。而 *AMN由Binder派生，实现了IActivityManager接口。*
- *客户端使用ActivityManager类* 。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。 *在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。*
** AMS的调用轨迹
- AMS由SystemServer的ServerThread线程创建，它的调用轨：
  - 1.调用main函数，得到一个Context对象
  - 2.将SystemServer进程可加到AMS中，并被它管理
  - 3.将ActivityManagerService的SettingsProvider放到SystemServer进程中来运行。
  - 4.在内部保存WindowManagerService（以后简称WMS）
*** 1.Main中的调用
- 1.创建AThread线程。
- 2.ActivityThread.systemMain函数。初始化ActivityThread对象。
- 3.ActivityThread.getSystemContext函数。用于获取一个Context对象，从函数名上看，该Context代表了System的上下文环境。
- 4.AMS的startRunning函数。
**** 步骤1：创建AThread线程
- 虽然AMS的main函数由ServerThread线程调用，但是AMS自己的工作并没有放在ServerThread中去做，而是新创建了一个线程，即AThread线程。其主要工作就是创建AMS对象，然后通知AMS的main函数。
- AMS构造函数的工作：
  - 创建BSS、USS、mProcessStats （ProcessStats类型）、mProcessStatsThread线程，这些都与系统运行状况统计相关。
  - 创建/data/system目录，为mCompatModePackages（CompatModePackages类型）和mConfiguration（Configuration类型）等成员变量赋值。
**** 步骤2：ActivityThread.systemMain函数。初始化ActivityThread对象
- 它 *ActivityThread代表一个应用进程的主线程* （ *对于应用进程来说，ActivityThread的main函数确实是由该进程的主线程执行* ），其职责就是调度及执行在该线程中运行的四大组件。
- *应用进程* 指那些 *运行APK的进程，它们由Zyote 派生（fork）而来，上面运行了dalvik虚拟机* 。与应用进程相对的就是 *系统进程（包括Zygote和SystemServer）* 。
- 前面所说的 *ActivityThread代表应用进程* （其上运行了APK）的主线程，而 *SystemServer并非一个应用进程* ，那么为什么此处也需要ActivityThread呢？
  - 还记得在 *PackageManagerService分析中提到的framework-res.apk* 吗？ *这个APK除了包含资源文件外，还包含一些Activity（如关机对话框），这些Activity实际上运行在SystemServer进程中。从这个角度看，SystemServer是一个特殊的应用进程。*
  - *通过ActivityThread可以把Android系统提供的组件之间的交互机制和交互接口（如利用Context提供的API）也拓展到SystemServer中使用。*
- 调用systemMain函数结束后：
  - 1.得到一个ActivityThread对象，它代表应用进程的主线程。
  - 2.得到一个Context对象，它背后所指向的Application环境与framework-res.apk有关。
- *systemMain函数将为SystemServer进程搭建一个和应用进程一样的Android运行环境。*
**** 步骤3：ActivityThread.getSystemContext函数。用于获取一个Context对象，从函数名上看，该Context代表了System的上下文环境。
- 调用该函数后，将得到一个代表系统进程的Context对象。
  
[[./pic/activityService_20220829_082224.png]]
**** 步骤4：AMS的startRunning函数。
- 就是调用startRunning
**** 总结：
- AMS的main函数的目的有两个：
  - 1.首先也是最容易想到的目的是创建AMS对象。
  - 2.另外一个目的比较隐晦，但是非常重要，那就是创建一个供SystemServer进程使用的Android运行环境。

*** 2.AMS的setSystemProcess(将SystemServer进程可加到AMS中，并被它管理)
**** 调用ActivityThread的installSystemApplicationInfo函数
- installSystemApplicationInfo函数的参数为一个ApplicationInfo对象，该对象由AMS通过Context查询PKMS中一个名为“android”的package得来，目的仅仅是为了创建一个Android运行环境。
- 由于framework-res.apk是一个APK文件，和其他APK文件一样，它应该运行在一个进程中。而 *AMS是专门用于进程管理和调度的* ，所以运行APK的进程应该在AMS中有对应的管理结构。因此 *AMS下一步工作就是将这个运行环境和一个进程管理结构对应起来并交由AMS统一管理。*
**** AMS对进程的管理
- AMS中的 *进程管理结构是ProcessRecord。*
  
[[./pic/activityService_20220829_082611.png]]
- 由上图可知：
  - 1. *ApplicationThreadNative实现了IApplicationThread接口* 。从该接口定义的函数可知， *AMS通过它可以和应用进程进行交互* ，例如，AMS启动一个Activity的时候会调用该接口的scheduleLaunchActivity函数。
  - 2. *ActivityThread通过成员变量mAppThread指向它的内部类ApplicationThread* ，而ApplicationThread从ApplicationThreadNative派生。
- *当AMS想要停止（stop）一个Activity时，会调用对应进程IApplicationThread Binder客户端的scheduleStopActivity函数* 。该函数 *服务端* 实现的就是 *向(客户端应用的)ActivityThread所在线程发送一个消息* 。在 *应用进程(客户端中)中，ActivityThread运行在主线程中，所以这个消息最终在主线程被处理。*
- *ProcessRecord* 除 *保存的信息包括：*  和 *与应用进程通信的IApplicationThread对象* 外，还保存了 *进程名* 、不同状态对应的 *Oom_adj* 值及一个 *ApplicationInfo* 。一个进程虽然可运行多个Application，但是 *ProcessRecord一般保存该进程中先运行的那个Application的ApplicationInfo。*
**** 保存该ProcessRecord对象
- AMS中有两个成员变量用于保存ProcessRecord，一个是 *mProcessNames* ，另一个是 *mPidsSelfLocked* ，如下图所示为这两个成员变量的数据结构示意图。
  
[[./pic/activityService_20220829_083053.png]]
- 仔细看上面的图，是不是至少有一处地方(uid vs pid)写错了？我觉得两个要么都是uid要么都是pid才对？
**** AMS的setSystemProcess总结：
- 现在来总结回顾setSystemProcess的工作：
  - 1.注册AMS、meminfo、gfxinfo等服务到ServiceManager中。
  - 2. *根据PKMS(PackageManagerService)返回的ApplicationInfo初始化Android运行环境* ，并 *创建一个代表SystemServer进程的ProcessRecord，从此，SystemServer进程也并入AMS的管理范围内。*
 
*** 3.AMS的installSystemProviders(3.将ActivityManagerService的SettingsProvider放到SystemServer进程中来运行)
- SystemServer中很多Service都需要向settings数据库查询配置信息。为此，Android提供了一个SettingsProvider来帮助开发者。该Provider在SettingsProvider.apk中，installSystemProviders就会加载该APK并把SettingsProvider放到SystemServer进程中来运行。
- 这里AMS向PKMS查询满足要求的ProviderInfo，最重要的查询条件包括：进程名和进程uid。同时AMS对ContentProvider进行管理（这也是查询ProviderInfo的原因）。
 
**** ASM的systemReady
- 可以分为三个阶段的工作:
***** 第一阶段：
- 发送并处理与 *PRE_BOOT_COMPLETED* 广播相关的事情。 *该广播接收者的工作似乎和系统升级有关。(目前的工作案例中我还不曾涉及到这一块儿)*
***** 第二阶段：
- 1.杀死那些竟然在AMS还未启动完毕就先启动的应用进程。注意，这些应用进程一定是APK所在的Java进程，因为只有应用进程才会向AMS注册，而一般Native（例如mediaserver）进程是不会向AMS注册的。
- 2. *从Settings数据库中获取配置信息，目前只取4个配置参数* ，分别是："*debug_app*"（ /设置需要debug的app的名称/ ）、"*wait_for_debugger*"（ /如果为1，则等待调试器，否则正常启动debug_app/ ）、"*always_finish_activities*"（ /当一个activity不再有地方使用时，是否立即对它执行destroy/ ）、"*font_scale*"（ /用于控制字体放大倍数，这是Android 4.0新增的功能/ ）。
- 以上配置项由Settings数据库的System表提供。
- 附加：自己先前读 *安卓系统Settings源码的时候，它提供了四个缺省表，System，Default, Global, + ?*
***** 第三阶段：
- 1.调用systemReady设置的回调对象goingCallback的run函数。
  - 在run中，调用一些服务的systemReady函数和启动Watchdog。
- 2.启动那些声明了persistent的APK。persistent apk就是，在系统启动的时候就可以运行的apk.
#+begin_SRC xml
<application
    android:persistent="true|false">
</application>
#+END_SRC 
            - 在我们开发系统级的App时，很有可能就会用persistent属性。当在AndroidManifest.xml中将persistent属性设置为true时，那么该App就会具有如下两个特性：
              - 系统刚起来的时候，该App也会被启动起来
              - App被强制杀掉后，系统会重启该App。这种情况只针对系统内置的App，第三方安装的App不会被重启。
- 3.启动桌面，在Home启动成功后，AMS才发送 *ACTION_BOOT_COMPLETED* 广播(这个广播就是自己工作应用中经常会用到/会接听用于开机启动完成后应用必要的优先配置等使用的广播了)
 
*** ActivityManagerService总结
- 1. *AMS的main函数* ： *创建AMS实例* ，其中最重要的工作是 *创建Android运行环境，得到一个ActivityThread和一个Context对象* 。
- 2. *AMS的setSystemProcess()函数* ：该函数 *注册AMS和meminfo等服务到ServiceManager中* 。另外， *它为SystemServer创建了一个ProcessRecord对象* 。由于 *AMS是Java世界的进程管理及调度中心，要做到对Java进程一视同仁，尽管SystemServer贵为系统进程，此时也不得不将其并入AMS的管理范围内。*
- 3. *AMS的installSystemProviders：* 为 *SystemServer加载SettingsProvider。*
- 4.AMS的 *systemReady* ：做 *系统启动完毕前最后一些扫尾工作。该函数调用完毕后，HomeActivity将呈现在用户面前。*
 
* am命令启动一个Activity
- am和pm一样，也是一个脚本，它用来和AMS交互，如启动Activity、启动Service、发送广播等。其核心文件在Am.java中。
** AMS的startActivityAndWait函数分析
** Task、Back Stack、ActivityStack及Launch mode
- 一个Acitivity的启动是由一个应用进程发起的，IApplicationThread是应用进程和AMS交互的通道，也可算是调用进程的标示。
- mMainStack为AMS的成员变量，类型为ActivityStack。他通过startActivityAndWait开始启动activity。
- 对多Task的情况来说，系统只支持一个处于前台的Task，即用户当前看到的Activity所属的Task，其余的Task均处于后台，这些后台Task内部的Activity保持顺序不变。用户可以一次将整个Task挪到后台或者置为前台。
- Task内部Activity的组织方式如下：
  
[[./pic/activityService_20220829_084557.png]]
- Android通过先入后出的方式来组织Activity。数据结构中的Stack即以这种方式工作。
- 为了应对多个Task的组织及管理方式，Android设计了一个ActivityStack类来负责上述工作。
  
[[./pic/activityService_20220829_084613.png]]
- *Activity由 /ActivityRecord/ 表示* ， *Task由 /TaskRecord/ 表示* 。ActivityRecord的task成员指向该Activity所在的Task。state变量用于表示该Activity所处的状态（包括INITIALIZING、RESUMED、PAUSED等状态）。
- ActivityStack用mHistory这个ArrayList保存ActivityRecord。 *令人大跌眼镜的是，该mHistory保存了系统中所有Task的ActivityRecord，而不是针对某个Task进行保存。*
  - 每每读到这种时候，小伙伴们就惊呆了：镜片掉了一地，隐形掉了一地，眼珠也掉了一地。。。。。
  - *ActivityStack的mMainStack* 成员比较有意思， *它代表此ActivityStack是否为主ActivityStack* 。有主必然有从，但是目前系统中只有一个ActivityStack，并且它的mMainStack为true。
  - 从ActivityStack的命名可推测，Android在开发之初也想用ActivityStack来管理单个Task中的ActivityRecord（在ActivityStack.java的注释中说过，该类为“ *State and management of a single stack of activities* ”），但不知何故，在现在的代码实现将所有Task的ActivityRecord都放到mHistory中了，并且依然保留mMainStack。
- *ActivityStack采用数组的方式保存所有Task的ActivityRecord(这里真的是数组吗？还是写错了？)* ，并且 *没有成员保存TaskRecord* 。
  - *这种实现方式少了TaskRecord一级的管理，直接以ActivityRecord为管理单元* 。这种做法 *能降低管理方面的开销。但是 缺点是弱化了Task的概念，结构不够清晰。*
- *启动模式* ：分别是 *standard、singleTop、singleTask和singleInstance* 。描述的是 *activity之间的关系。*
- *标志* ： *FLAG_ACTIVITY_NEW_TASK，FLAG_ACTIVITY_CLEAR_TASK，FLAG_ACTIVITY_CLEAR_TOP* 。描述的是 *Activity和Task关系的。*
** startActivityAndWait
- 该函数的目标是启动com.dfp.test.TestActivity，假设系统之前没有启动过该Activity，则
  - 1.由于在am中设置了FLAG_ACTIVITY_NEW_TASK标志，因此除了会创建一个新的ActivityRecord外，还会新创建一个TaskRecord。
  - 2.还需要启动一个新的应用进程以加载并运行com.dfp.test.TestActivity的一个实例。
  - 3.如果TestActivity不是Home，还需要停止当前正在显示的Activity。
*** 具体步骤：
- 1.首先需要通过PKMS查找匹配该Intent的ActivityInfo。
- 2.处理FLAG_CANT_SAVE_STATE的情况，但系统目前不支持此情况。
- 3.另外，获取调用者的pid和uid。由于本例的caller为null，故所得到的pid和uid均为am所在进程的uid和pid。
- 4.启动Activity的核心函数是startActivityLocked。
- 5.根据返回值做一些处理，因为目标Activity要运行在一个新的应用进程中，就必须等待那个应用进程正常启动并处理相关请求
** startActivityLocked主要工作
- 1.处理sourceRecord及resultRecord。其中，sourceRecord表示发起本次请求的Activity，resultRecord表示接收处理结果的Activity（启动一个Activity肯定需要它完成某项事情，当目标Activity将事情成后，就需要告知请求者该事情的处理结果）。 *在一般情况下，sourceRecord和resultRecord应指向同一个Activity* (这里这么写是故意误导弱弱们的吧？)。
- 2.处理app Switch。如果AMS当前禁止appswitch，则只能把本次启动请求保存起来，以待允许app switch时再处理。从代码中可知，AMS在处理本次请求前，会先调用doPendingActivityLaunchesLocked函数，在该函数内部将启动之前因系统禁止appswitch而保存的Pending请求。
- 3.调用startActivityUncheckedLocked处理本次Activity启动请求，为新创建的ActivityRecord找到一个合适的Task。
- *下面是来自另一处更变详尽的解释*
-  startActivityLocked()方法在创建ActivityRecord前，还做了如下几个操作：
    1. 确定sourceRecord和resultRecord，这两个变量均为ActivityRecord类型，前者代表请求启动当前activity的activity；后者表示当前的activity在启动之后需要返回结果的ActivityRecord，一般情况下，如果sourceRecord的activity使用startActivityForResult()启动当前activity并且requestCode>=0时，则resultRecord不为空，且resultRecord=sourceRecord。
       
[[./pic/activityService_20220829_094826.png]]
   - 还有一种特殊的情况，当启动一个activity时，启动的Intent设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT标志，在这种情况resultRecord并不指向sourceRecord，而是指向sourceRecord的sourceRecord，比较绕上个图先
     
[[./pic/activityService_20220829_094904.png]]
   - 如上图所示，Activity A 启动了Activity B，Activity B又启动了C，A-->B-->C, 这种情况下，A启动B要求B返回result给A，但是如果B在启动C时，Intent设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT标志，那么此时将会交由C向A setResult。为了避免冲突，B启动C时不得指定resultRecord>=0。
#+BEGIN_SRC csharp
ActivityRecord sourceRecord = null;  
ActivityRecord resultRecord = null;  
if (resultTo != null) {  
    int index = indexOfTokenLocked(resultTo);  
    if (DEBUG_RESULTS) Slog.v(  
        TAG, "Sending result to " + resultTo + " (index " + index + ")");  
    if (index >= 0) {  
        sourceRecord = (ActivityRecord)mHistory.get(index);  
        if (requestCode >= 0 && !sourceRecord.finishing)  
            resultRecord = sourceRecord;  
    }  
}  
int launchFlags = intent.getFlags();  
if ((launchFlags&Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0  
        && sourceRecord != null) {  
    // Transfer the result target from the source activity to the new  
    // one being started, including any failures.  
    if (requestCode >= 0) { 
        return START_FORWARD_AND_REQUEST_CONFLICT;  
    resultRecord = sourceRecord.resultTo;  
    resultWho = sourceRecord.resultWho;  
    requestCode = sourceRecord.requestCode;  
    sourceRecord.resultTo = null;  
    if (resultRecord != null) 
        resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);  
}
#+END_SRC 
** startActivityUncheckedLocked的分析：
- 步骤1：确定是否需要为新的Activity创建一个Task，即是否设置FLAG_ACTIVITY_NEW_TASK标志。
- 步骤2：找到一个合适的Task，然后对应做一些处理。
- 步骤3：根据条件判断使用原有的TaskRecord还是新建一个，并调用startActivityLocked函数进行处理。
- 步骤4：进行Activity之间的动画切换。
- 总结：首先创建ActivityRecord和TaskRecord并将ActivityRecord添加到mHistory末尾，然后调用resumeTopActivityLocked启动它。
** resumeTopActivityLocked分析
- 在当中mResumedActivity指向上一次启动的Activity，也就是当前界面显示的这个Activity，如果mHistory中没有要启动的Activity，则启动Home。
- （接startActivityUncheckedLocked的分析）如果该ActivityRecord已有对应的进程存在，则只需要重启Activity。此进程还不存在，所以要先创建一个应用进程,通过startProcessLocked。
** startProcessLocked分析
- 通过发送消息给Zygote以派生一个应用进程（应用进程）。
*** 应用进程的创建及初始化
- 应用进程的入口是ActivityThread的main函数，它是在主线程中执行的。
  - 1、在main函数内部将创建一个消息循环Loop，接着调用ActivityThread的attach函数，最终将主线程加入消息循环。
  - 2、AMS创建一个应用进程后，会设置一个超时时间（一般是10秒）。如果超过这个时间，应用进程还没有和AMS交互，则断定该进程创建失败。所以，应用进程启动后，需要尽快和AMS交互，即调用AMS的attachApplication函数。在该函数内部将调用attachApplicationLocked。
*** attachApplicationLocked分析
**** 第一步：
- *设置代表该应用进程的ProcessRecrod对象的一些成员变量* ，例如 *用于和应用进程交互的thread对象* 、 *进程调度优先级* 及 *oom_adj的值* 等。
- 从消息队列中撤销 *PROC_START_TIMEOUT_MSG* (这种超时机制在车载系统的双向信号传递控制器的信号下发中也是经常用到)。 
- 至此，该进程启动成功。
**** 第二步：
- 在generateApplicationProvidersLocked函数内部查询（根据进程名，uid确定）PKMS以获取需运行在该进程中的ContentProvider，为调用ApplicationThread的 *bindApplication* 做准备。
- 刚创建的这个进程并不知道自己的历史使命是什么，甚至连自己的进程名都不知道，只能设为"< *pre-initialized* >"。其实， *Android应用进程的历史使命是AMS在其启动后才赋予它的* ，这一点和我们理解的一般意义上的进程不太一样。根据之前的介绍， *Android的组件应该运行在Android运行环境中* 。 *创建应用进程这一步只是创建了一个能运行Android运行环境的容器* 。
- *bindApplication* 的功能就是 *创建并初始化位于该进程中的Android运行环境。*
**** 第三步：
应用进程已经准备好了Android运行环境， *接着将获取ActivityStack中一个需要运行的ActivityRecord并启动，最后通知应用进程启动Activity和Service等组件* ，其中 *用于启动Activity的函数是ActivityStack.realStartActivityLocked。*
 
*** ActivityStack的realStartActivityLocked分析
- 它里面有两个关键函数，分别是： *scheduleLaunchActivity和completeResumeLocked。*
  - scheduleLaunchActivity用于和应用进程交互，通知它启动目标Activity。
  - completeResumeLocked将继续AMS的处理流程。
**** scheduleLaunchActivity
- 它 *保存AMS发送过来的参数信息，向主线程发送消息* ，该消息的处理在 *handleLaunchActivity* 中进行。在其中 *根据ApplicationInfo得到对应的PackageInfo。*
- *通过Java反射机制创建目标Activity，将在内部完成Activity生命周期的前两步，即调用其onCreate和onStart函数* 。我们的目标com.dfp.test.TestActivity创建完毕。
- 调用 *handleResumeActivity* ，会 *在其内部调用目标Activity的onResume函数。*
**** completeResumeLocked
- AMS给了应用进程10秒的时间，希望它在10秒内调用activityIdle函数。这个时间不算长，和前面AMS等待应用进程启动的超时时间一样。
- 在activityIdle中设置了请求超时处理。并调用activityIdleInternal函数，处理被暂停的Activity。
- 如果 *被暂停的Activity处于finishing状态* （例如Activity在其onStop中调用了finish函数），则调用 *finishCurrentActivityLocked* 。否则，要调用 *stopActivityLocked* 处理暂停的Activity。
 
*** ApplicationThread的bindApplication分析
- 该函数将为应用进程绑定一个Application。
- *ApplicationThread* 接收到来自AMS的指令后，均会 *将指令中的参数封装到一个数据结构中* ，然后 *通过发送消息的方式转交给主线程去处理* 。 *BIND_APPLICATION* 最终将由 *handleBindApplication* 函数处理。
- bindApplication函数将设置一些初始化参数，其中最重要的有：
  - 1.为之前的无名进程设置进程名，并初始化参数
  - 2.创建一个Application对象，该对象是本进程中运行的第一个Application。
  - 3.如果该Application有ContentProvider，则应安装它们。
** 总结:
- 在应用进程启动后，需要尽快调用AMS的attachApplication函数，该函数是这个刚呱呱坠地的应用进程第一次和AMS交互。此时的它还默默“无名”，连一个确定的进程名都没有。不过没关系，attachApplication函数将根据创建该应用进程之前所保存的ProcessRecord为其准备一切“手续”。
- attachApplication准备好一切后，将调用应用进程的bindApplication函数，在该函数内部将发消息给主线程，最终该消息由handleBindApplication处理。handleBindApplication将为该进程设置进程名，初始化一些策略和参数信息等。另外，它还创建一个Application对象。同时，如果该Application声明了ContentProvider，还需要为该进程安装ContentProvider。
  
[[./pic/activityService_20220829_090302.png]]
** startActivity总结
- 1.行程的起点是am。am是Android中很重要的程序。我们利用amstart命令，发起本次目标Activity的启动请求。
- 2.接下来进入ActivityManagerService和ActivityStack这两个核心类。对于启动Activity来说，这段行程又可分细分为两个阶段：第一阶段的主要工作就是根据启动模式和启动标志找到或创建ActivityRecord及对应的TaskRecord；第二阶段工作就是处理Activity启动或切换相关的工作。
- 3.首先AMS直接创建目标进程并运行Activity的流程，其中涉及目标进程的创建，在目标进程中Android运行环境的初始化，目标Activity的创建以及触发onCreate、onStart及onResume等其生命周期中重要函数调用等相关知识点。
- 4.接着AMS先pause当前Activity，然后再创建目标进程并运行Activity的流程。其中牵扯到两个应用进程和AMS的交互，其难度之大可见一斑。


* task管理
** task和activity以及process整体的关系
- AMS提供了一个ArrayList mHistory来管理所有的activity，activity在AMS中的形式是ActivityRecord，task在AMS中的形式为TaskRecord，进程在AMS中的管理形式为ProcessRecord。如下图所示
  
[[./pic/activityService_20220829_095916.png]]
- 从图中我们可以看出如下几点规则：
  - 1. 所有的ActivityRecord会被存储在mHistory管理；
  - 2. 每个ActivityRecord会对应到一个TaskRecord，并且有着相同TaskRecord的ActivityRecord在mHistory中会处在连续的位置；
  - 3. 同一个TaskRecord的Activity可能分别处于不同的进程中，每个Activity所处的进程跟task没有关系；
- 因此，在分析Activity管理之前，先了解一下这个规则。
- 在android应用开发中，task是一个很重要的概念，在文章开始，我就画出了task和activity以及process整体的关系，在这里还需要说明一下，task和application的区别，
- application在android中的作用仅仅是activity在未被使用前的一个容器，我们开发android应用程序时，需要一个application来组织我们开发的activity，application和activity之间是一个静态关系，并且是一一对应的关系；也就是说我们开发的activity在PM中的最终形式是唯一的，永远对应一个application。
- 而task和activity之间的关系是动态的关系，是我们在运行应用程序时，activity的调用栈，同一个task中的activity可能来自不同的application。
** 1 Intent.FLAG_ACTIVITY_NO_USER_ACTION
- 检查Intent是否设置了Intent.FLAG_ACTIVITY_NO_USER_ACTION，如果设置了，则在activity pause之前将不再调用activity的onUserLeaveHint()方法。
#+BEGIN_SRC csharp
mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;  
if (DEBUG_USER_LEAVING) Slog.v(TAG, "startActivity() => mUserLeaving=" + mUserLeaving);  
#+END_SRC 
** 2 Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP
- 检查Intent是否设置了Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP，这个标志我有点困惑，从它的注释可以看出 *它的含义是指如果设置了该flag，那么mHistory中最top的activity在后续的处理中将不被视为top，而将前一个activity视为top，如A-->B-->C，将B视为top。*
- 这个top activity的作用很大，涉及到后面对task的处理。但是目前来看这个flag并没有起到该有的作用，代码中判断如果设置了该标志，那么AMS将会视当前正在启动的activity为top，然后去mHistory中去查找它的前一个activity为后续task处理的top activity(topRunningNonDelayedActivityLocked()中实现)，但是现在的问题是此时此刻，正在启动的activity并不存在于mHistory中，因为我们在前一个函数中刚刚创建了这个ActivityRecord。如下面代码所示：
#+BEGIN_SRC csharp
ActivityRecord notTop = (launchFlags&Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;  
#+END_SRC 
- 因此，感觉这个flag的意义不是太大。
** 3 何时应该创建新的task
- sourceRecord为空；
- sourceRecord的activity的launch mode为ActivityInfo. *LAUNCH_SINGLE_INSTANCE* ，也就是sourceRecord activity的task只允许一个activity；
- 当前activity的launch mode为ActivityInfo. *LAUNCH_SINGLE_INSTANCE* 或者r.launchMode == ActivityInfo. *LAUNCH_SINGLE_TASK* 。
- *以上几种情况* ，均可视为需要为启动的activity创建一个新的task.
#+BEGIN_SRC csharp
if (sourceRecord == null) {  
// This activity is not being started from another...  in this  
// case we -always- start a new task.  
    if ((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {  
        Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "  
               + intent);  
        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;  
    }  
} else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {  
// The original activity who is starting us is running as a single  
// instance...  this new activity it is starting must go on its  
// own task.  
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;  
} else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE  
           || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {  
// The activity being started is a single instance...  it always  
// gets launched into its own task.  
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;  
}  
#+END_SRC 
** 4 Intent.FLAG_ACTIVITY_NEW_TASK时断开与Caller依赖
- 如果启动的activity需要新的task，那么新启动的activity将会与其caller断开依赖关系，这个关系主要是指result反馈，A-->B,如果A是通过startActivityForResult()请求启动的，并且requestCode >=0,那么如果B是在新的task中，那么B在finish的时候将不再向A反馈result，而是在启动过程中就会向A反馈一个RESULT_CANCELED。
#+BEGIN_SRC csharp
if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {  
// For whatever reason this activity is being launched into a new  
// task...  yet the caller has requested a result back.  Well, that  
// is pretty messed up, so instead immediately send back a cancel  
// and let the new task continue launched as normal without a  
// dependency on its originator.  
    Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");  
    sendActivityResultLocked(-1,  
                             r.resultTo, r.resultWho, r.requestCode,  
                             Activity.RESULT_CANCELED, null);  
    r.resultTo = null;  
}  
#+END_SRC 
** 5 Task复用
*** 5.1 Task的基本属性 
- 检查mHistory中是否有task可复用，在分析这段之前，先了解一下 *task的一些基本概念*
  - task的root activity是指如果一个activity启动时创建的了一个新的task，那么这个activity是task的root activity；
  - task.affinity是指root activity的affinity；
  - task.intent是指启动root activity的Intent；
  - task.affinityIntent是指activity在进行了TaskReparenting之后，AMS为activity分配了新的task，该task的affinityIntent则是启动该activity时的Intent，此时task.intent==null。
- TaskReparenting操作举例说明一下，假如有2个activity拥有不同的affinity，且自Activity A中启动Activity B，假如Activity A是所在task的root activity，如下图示：
  
[[./pic/activityService_20220829_101320.png]]
- 假如Activity B设置了ActivityInfo.FLAG_ALLOW_TASK_REPARENTING，那么如果此时另外一个application启动了Activity B并要求其在新的task中，那么此时的Activity B将被从Task A中移动到新的task中，如下图所示：
  
[[./pic/activityService_20220829_101333.png]]
- 这个过程就称之为TaskReparenting，关于TaskReparenting，我会专门写一篇文章分析一下。下面来分析task复用的过程。
*** 5.2 查找可复用的task
- 以下3种条件需要检查是否有有task可复用
#+BEGIN_SRC csharp
(launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &&
    (launchFlags&Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0;
r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
#+END_SRC 
- 第⑴是一个组合条件，Intent. *FLAG_ACTIVITY_MULTIPLE_TASK* 不能单独使用，它 *是和Intent.FLAG_ACTIVITY_NEW_TASK结合起来使用的* ， *如果设置了Intent.FLAG_ACTIVITY_MULTIPLE_TASK，那么将会永远启动一个新的task，不管是否有可复用的task。*
- 为什么是这3种条件，从android的开发文档中，我们可知LAUNCH_SINGLE_TASK和LAUNCH_SINGLE_INSTANCE两种launch mode的activity只允许作为task的root activity，既然是作为root activity，那么它所处的task的affinity必然是和它的是一样的，因此从mHistory中找打一个和自己的affinity相同的task是非常有必要的。
- 而对于设置了Intent.FLAG_ACTIVITY_NEW_TASK的Intent来说，并且没有设置Intent.FLAG_ACTIVITY_MULTIPLE_TASK，那么同样的，它也必须是作为它所处的task的root activity。道理是一样的。
**** AMS去mHistory中查找可复用的task，查找这个task的规则如下：    
***** ⑴ launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE的情况，遵循如下规则： @findTaskLocked()
- ① 查找mHistory中是否有与要启动的activity相同affinity的task，上面也提过这几类activity启动时，均是作为task的root activity，并且其task的affinity必须和自己的affinity相同，因此首先需要去mHistory查找和自己affinity相同的task。
- ② 如果activity没有affinity，即属性android:taskAffinity设置为“”，空字符串时。此时AMS就会去mHistory中去查找是否有task的root activity和启动的activity相同，通过比较 *task.intent.getComponent()* 和 *启动activity的Comeponent* 比较，为什么是root activity，前面分析过了；
- ③ 如果task.Intent为空，这种情况发生在TaskReparenting之后，TaskReparenting之后，AMS为这个activity创建一个新的task，并将启动这个activity的Intent赋值给task.affinityIntent，并且此时的task.Intent==null。此时就需要比较 *task.affinityIntent.getComponent()* 和 *启动activity的Comeponent* 比较，看是否和启动的activity相同。
- *以上3个规则中* ，均是返回找的task中最上面的activity，而不一定是task的activity，至于如何处理要启动的activity和task中已有的activity，后面会介绍。
***** ⑵ launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE的情况，遵循如下规则： @findActivityLocked()
- 对于ActivityInfo. *LAUNCH_SINGLE_INSTANCE* 启动模式来说， *它所处的task中只允许有它一个activity* ，因此它的规则只符合上面规则中的②二；
- 对于第①条，由于设置了ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity，它只能自己独处一个task，不可能和别人共享同一个task，因此mHistory即使存在了与该activity有相同的affinity的activity，如果这个activity和启动的activity不同，那么ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity也不可能和它共用一个task，因此这第①条完全可以不用检查。
- 对于第②条，由于该模式的activity独处一个task，因此完全没有可能所处的task的affinity和自己的affinity不同，因此，假如mHistory存在相同的activity与启动的activity相同，那么这个activity的affinity必然和自己的相同。所以对于这种模式，第②条囊括了其他模式的①②两条。
- 对于第③条，同样的道理，ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity不可能处在与自己不同affinity的task中，因此不可能出现TaskReparenting操作，所以这条也不需要。
#+BEGIN_SRC csharp
ActivityRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE  
    ? findTaskLocked(intent, r.info)  
    : findActivityLocked(intent, r.info);  
#+END_SRC 
- 在获得taskTop之后，下面来分析这个taskTop的意义。
*** 5.3 task移到mHistory前端
- 由于我们要复用task，因此需要将taskTop所在的task移到mHistory前端 。
#+BEGIN_SRC csharp
ActivityRecord curTop = topRunningNonDelayedActivityLocked(notTop);  
if (curTop.task != taskTop.task) {  
    r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);  
    boolean callerAtFront = sourceRecord == null  
        || curTop.task == sourceRecord.task;  
    if (callerAtFront) {  
// We really do want to push this one into the  
// user's face, right now.  
        moveTaskToFrontLocked(taskTop.task, r);  
    }  
}  
#+END_SRC 
*** 5.4 Reset Task
- 如果Intent设置Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，最常见的情况，当从Home启动应用程序时，会设置这个flag；从recently task进入应用程序，则不会设置这个falg。
- 设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，AMS会对复用的task作如下处理，下面称这个可复用的task为复用task：
**** 设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，AMS会对复用的task作如下处理
***** ⑴ mHistory中，对于复用task中的除root activity外的activity，有如下处理
- 在此之前，先介绍 *activity的几个关键属性：*
  - 一① 如果 *复用task在后台时间超过30min* ，那么 *在这个过程中将删除除root activity之外的所有的activity* ；
  - 二② 如果 *新启动的activity* 设置了属性ActivityInfo. *FLAG_ALWAYS_RETAIN_TASK_STATE* ，那么表明 *它并不要求后台20min的复用task删除activity；*
  - 三③ 如果 *新启动的activity* 设置了属性ActivityInfo. *FLAG_CLEAR_TASK_ON_LAUNCH* ，那么表明 *不论复用task在后台是否超过30min，一律要求删除除root activity之外的所有的activity；*
  - 四④ *复用task中的activity* 设置了属性ActivityInfo. *FLAG_FINISH_ON_TASK_LAUNCH* ，那么 *复用task从home中再次被启动到前台时，这个activity会被删除；*
  - 五⑤ *复用task中的activity* 设置了属性ActivityInfo. *FLAG_ALLOW_TASK_REPARENTIN* ，并且这个 *activity的resultTo为空* ，那么也就是说这个activity和它的caller没有依赖关系，那么AMS认为这个activity暂时没有用处了， *需要对其进行TaskReparenting操作，最好的方法是把它放到mHistory栈底，不影响其他task。*
  - 六⑥ *复用task中的activity* 的Intent设置属性Intent. *FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET* ，那么下次再从home中进入到task中，那么 *将删除设置了该属性的activity以上所有的activity* ，例如A-->B-->C ==> D-->E,加入在C启动D时设置了该属性，那么下次从HOME中再次进入到这个task中时，将会是A-->B-->C。
  - 七⑦ 如果 *复用task中的activity的resultTo不为空* ，也就是启动这个activity的是一个activity，那么 *这个activity的处理将按照它的前一个activity的处理方式来处理* ，不管 *在何时情况下，它的前一个activity都是启动它的activity* ，(即便resultTo不是前一个activity，如设置了Intent. *FLAG_ACTIVITY_FORWARD_RESULT*) 。如果复用task中每个activity的resultTo都不为空，并且上述处理优先级在其前面的属性没有设置的话，那么 *这个复用task中的activity将不作任何的处理(这种情况没有看懂，不知道这种情况为什么可以不用处理？？？)* 。
- 一般情况下，activity的resultTo都不为空，除非设置了Intent. *FLAG_ACTIVITY_FORWARD_RESULT* ，那么此时被启动的activity的caller的resultTo将会为空。
- task中的activity的属性设置是上述属性的组合，因此 *reset task过程要按照一定的优先级来处理* ，上述属性的处理优先级是： *六⑥ = 四④ > 七⑦ > 五⑤ > 三③ = 二② > 一①*
          - 具体操作顺序如下：
  - ♣ 根据六⑥，四④条件来 *删除复用task中相应的activity；*
  - ♣ 七⑦条件下，将会 *暂时不做处理，再根据它的前一个activity的属性来做处理，即使这个activity设置了allowTaskReparenting；*
  - ♣ *如果activity的resultTo为空，并且满足条件五⑤* ，那么 *将其及其以上未作处理的，满足条件七⑦的所有activity，一并进行TaskReparenting操作，并放置在mHistory栈底。它们在mHistory栈底顺序如同在复用task中的顺序；*
  ♣ *根据一①二②三③的条件来删除复用task中相应的activity。*
***** ⑵ mHistory中，不属于复用task的activity，并且它的resultTo不为空，那么将根据它的前一个activity的处理来处理；
***** ⑶ mHistory中，不属于复用task，但是和当前启动的activity有相同affinity，并且允许TaskReparenting操作，那么将进行以下操作：
      - ♣ 如果满足上述的①②③④的条件，但是其中的task不是复用task，而是这个activity所处的task，那么将输出这个activity，而不是进行TaskReparenting操作。
  - 为什么非复用task中的activity，和当前启动的activity有相同affinity，并且允许TaskReparenting操作，满足了①②③④的条件之后要删除呢，为什么非复用task中的其他activity，不需要删除呢？
  - *正因为它和启动的activity有相同的affinity，因此AMS认为这个activity是和启动activity相关的，以后可能会重新调用，所以当其满足删除条件后,这时它将不允许TaskReparenting操作，并且不应该再允许它存在于其他的task中，此时应该删除。*
- ♣ 如果没有满足①②③④的条件，那么将会对其进行TaskReparenting操作，重新将其移动到复用task或新启动的task中。
      #+BEGIN_SRC csharp
          // If the caller has requested that the target task be  
          // reset, then do so.  
          if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {  
              taskTop = resetTaskIfNeededLocked(taskTop, r);  
          }  
                #+END_SRC 
- 上面就是这个复用task的reset 过程，它的执行过程是按照上述的⑴⑵⑶的顺序来执行的，下面给出一个图示，便于更好的理解reset task的过程。
  
[[./pic/activityService_20220829_104430.png]]
*** 5.5 判断是否有可复用的activity
- 如果mHistory中有可复用的task，那么在某些情况下并不需要启动这个activity，下面分析具体是什么情况：
- ⑴ Intent设置了Intent.FLAG_ACTIVITY_CLEAR_TOP，或者launchMode == ActivityInfo.LAUNCH_SINGLE_TASK，或者r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE；这3种条件有一个共同点，就是启动的activity启动之后，在这个task中,这个activity之上不能有其他的activity。
  - 一般情况下，需要将复用task中启动的activity之上的所有的activity删除，
  - 当activity的launchMode == ActivityInfo. *LAUNCH_MULTIPLE，即普通模式* ，并且 *Intent并未要求singletop模式* ，这种情况是 *连复用task中与启动activity相同的activity都要删除，也就是不希望复用相同的activity。*
  - *performClearTaskLocked()* 实现了上述功能，并返回可复用的activity。
#+BEGIN_SRC csharp
ActivityRecord top = performClearTaskLocked(  
    taskTop.task.taskId, r, launchFlags, true);  
#+END_SRC 
  - 如果有可复用的activity，并且这个activity是task的root activity，由于task的Intent是root activity的Intent，所以需要重新设置task的Intent。
  - 向可复用的activity发送新的Intent，通知它Intent的变化，最终会调用到这个activity的onNewIntent()方法。
- ⑵ 如果不满足⑴条件的话，但是启动的activity与复用task的root activity相同。
  - 如果此时Intent设置了Intent.FLAG_ACTIVITY_SINGLE_TOP，并且复用task的top activity正好是要启动的activity，则复用这个activity，同时更新activity的Intent，如果需要更新task的Intent。
  - 如果Intent没有设置了Intent.FLAG_ACTIVITY_SINGLE_TOP，即使设置了，但是当前的top activity不是正要启动的activity，那么会判断当前启动的Intent和task的Intent不同，那么将会重新启动这个activity。
  - 其他情况，将直接resume top的activity。
- ⑶ 如果⑴ ⑵条件均不满足，其实如果不满足⑴ ⑵条件的话，复用的task中就不存在与启动的activity相同的activity了，如果启动的Intent没有设置Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么一定不会复用任何的activity。
- (4) 如果⑴ ⑵条件均不满足，并且Intent设置了Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么需要检查当前复用task的Intent是否设置了Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。
- 如果没有设置，重新设置新的Intent,同样不可能复用activity。
- 这种情况下，将不会显示要启动的activity，而是改为显示复用的task中的内容，如下图：
  
[[./pic/activityService_20220829_104857.png]]
- 至此，整个Task复用，已经activity复用的过程就介绍完了，如果没有可复用的activity，则需要启动一个新的activity，如果有可复用的activity，那么activity的启动过程至此结束，直接调用resumeTopActivityLocked()resume top的activity即可。
- *以后的处理均为Task复用和activity复用失败之后的处理。*
** 6 singleTop和singleTask属性的处理
   - 这一部分是针对singleTop和singleTask属性的处理，前面分析Task复用的时候，也有对singleTop和singleTask属性的处理，两者有什么不同呢？
- Task复用中是启动的activity需要在新的task中，而这里的处理主要是针对同一个task。
- 当设置Intent.FLAG_ACTIVITY_SINGLE_TOP或者launchMode == ActivityInfo.LAUNCH_SINGLE_TOP或者launchMode == ActivityInfo.LAUNCH_SINGLE_TASK这几种情况下，如果top activity与启动的activity为同一个activity，那么将复用top activity，并直接resume top activity。
#+BEGIN_SRC csharp
if (top != null && r.resultTo == null) {  
    if (top.realActivity.equals(r.realActivity)) {  
        if (top.app != null && top.app.thread != null) {  
            if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0  
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP  
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {  
                logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);  
// For paranoia, make sure we have correctly  
// resumed the top activity.  
                if (doResume) {  
                    resumeTopActivityLocked(null);  
                }  
                if (onlyIfNeeded) {  
                    // We don't need to start a new activity, and  
                    // the client said not to do anything if that  
                    // is the case, so this is it!  
                    return START_RETURN_INTENT_TO_CALLER;  
                }  
                top.deliverNewIntentLocked(callingUid, r.intent);  
                return START_DELIVERED_TO_TOP;  
            }  
        }  
    }  
}  
#+END_SRC 
- r.resultTo == null这个条件是在startActivityForResult()的requestCode<0时成立。
- 为什么没有ActivityInfo. *LAUNCH_SINGLE_INSTANCE* ？这是 *因为这种启动模式，如果Task复用失败之后，直接启动为其启动一个Intent.FLAG_ACTIVITY_NEW_TASK即可。*
** 7 standard和singleInstance模式
   - 为什么代码中没有明显的针对ActivityInfo.LAUNCH_SINGLE_INSTANCE模式的处理？这是因为这种启动模式，如果Task复用失败之后，直接启动为其启动一个Intent.FLAG_ACTIVITY_NEW_TASK即可。
- ⑴ 设置了Intent.FLAG_ACTIVITY_NEW_TASK，则为该activity创建一个新的task；
- ⑵ 在当前的task中启动新的activity，
  - 一①当前的caller是一个activity，如果设置Intent.FLAG_ACTIVITY_CLEAR_TOP，当前的task如果存在要启动的activity(这个和上一节中的Task复用时的clear top过程不同，两者是互斥的过程，不冲突)，清除其上的所有的activity；
  - 二② 当前的caller是一个activity，如果设置Intent.FLAG_ACTIVITY_REORDER_TO_FRONT，这个flag表示如果启动的activity已经在当前的task中，那么如果当前启动的Intent设置了该flag，那么则会将这个activity从task中移动到top。
    - 如果A-->B-->C-->D，D启动B时，设置了该flag，那么将变为A-->C-->D-->B
    - ①②两个条件，则不需要再启动新的activity，直接resume top。
  - 三③  当前的caller是一个activity，其他情况则需要启动新的activity。
- ⑶ 当前的caller不是activity，那么仍将新启动的activity放在top的task中。
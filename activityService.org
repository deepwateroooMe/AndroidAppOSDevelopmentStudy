#+latex_class: cn-article
#+title: Android ActivityService相关的原理
#+author: deepwaterooo

* android内核剖析学习笔记：AMS（ActivityManagerService）内部原理和工作机制
** 一、ActivityManagerService提供的主要功能：
- （1）统一调度各应用程序的Activity
- （2）内存管理
- （3）进程管理
** 二、启动一个Activity的方式有以下几种：
- （1）在应用程序中调用startActivity启动指定的Activity
- （2）在Home程序中单击一个应用图标，启动新的Activity
- （3）按“Back”键，结束当前Activity，返回到上一个Activity
- （4）长按“Home”键，显示出当前正在运行的程序列表，从中选择一个启动
- 这四种启动方式的主体处理流程都会按照第一种启动方式运行，后面三种方式只是在前端消息处理上各有不同。
** 三、进程数据类ProcessRecord
- 该类的源代码在~\frameworks\base\services\java\com\android\server\am路径下。
- 一般情况下，一个APK文件运行时会对应一个进程，ProcessRecord用来记录一个进程中的相关信息，主要包含的变量有：
*** （1）进程文件信息：与该进程对应的APK文件的内部信息，如
    #+BEGIN_SRC csharp
final ApplicationInfo info; // all about the first app in the process
final String processName;   // name of the process
final ArrayMap<String, ProcessStats.ProcessState> pkgList 
    = new ArrayMap<String, ProcessStats.ProcessState>();   //保存进程中所有APK文件包名
    #+END_SRC 
*** （2）进程的内存状态信息：用于Linux系统的out of memory(OOM)情况的处理，当发生内存紧张时，Linux系统会根据进程的内存状态信息杀掉低优先级的进程，包括的变量有
    #+BEGIN_SRC csharp
int maxAdj;                 // Maximum OOM adjustment for this process
int curRawAdj;              // Current OOM unlimited adjustment for this process
int setRawAdj;              // Last set OOM unlimited adjustment for this process
int curAdj;                 // Current OOM adjustment for this proce
int setAdj;                 // Last set OOM adjustment for this process
    #+END_SRC 
- 变量中Adj的含义是调整值（adjustment）
*** （3）进程中包含的Activity、Provider、Service等，如下
#+BEGIN_SRC csharp
final ArrayList<ActivityRecord> activities = new ArrayList<ActivityRecord>();
final ArraySet<ServiceRecord> services = new ArraySet<ServiceRecord>();
final ArraySet<ServiceRecord> executingServices = new ArraySet<ServiceRecord>();
final ArraySet<ConnectionRecord> connections = new ArraySet<ConnectionRecord>();
final ArraySet<ReceiverList> receivers = new ArraySet<ReceiverList>();
final ArrayMap<String, ContentProviderRecord> pubProviders = new ArrayMap<String,             ContentProviderRecord>();
final ArrayList<ContentProviderConnection> conProviders = new ArrayList<ContentProviderConnection>();
#+END_SRC 
** 四、ActivityRecord数据类（Android 2.3以前版本叫HistoryRecord类）
- ActivityManagerService使用ActivityRecord数据类来保存每个Activity的信息，ActivityRecord类基于IApplicationToken.Stub类，也是一个Binder,所以可以被IPC调用。
- 主要包含的变量有：
*** （1）环境信息：Activity的工作环境，比如进程名称、文件路径、数据路径、图标、主题等，这些信息一般是固定的，比如以下变量
#+BEGIN_SRC csharp
final String packageName; // the package implementing intent's component
final String processName; // process where this component wants to run
final String baseDir;   // where activity source (resources etc) located
final String resDir;   // where public activity source (public resources etc) located
final String dataDir;   // where activity data should go
int theme;              // resource identifier of activity's theme.
int realTheme;          // actual theme resource we will use, never 0.
#+END_SRC 
*** （2）运行状态数据信息：如idle、stop、finishing等，一般为boolean类型，如下
#+BEGIN_SRC csharp
boolean haveState;      // have we gotten the last activity state?
boolean stopped;        // is activity pause finished?
boolean delayedResume;  // not yet resumed because of stopped app switches?
boolean finishing;      // activity in pending finish list?
boolean configDestroy;  // need to destroy due to config change?
#+END_SRC 
** 五、TaskRecord类
- ActivityManagerService中使用任务的概念来确保Activity启动和退出的顺序。
- TaskRecord中的几个重要变量如下：
#+BEGIN_SRC csharp
final int taskId;       // 每个任务的标识.
Intent intent;          // 创建该任务时对应的intent
int numActivities;   //该任务中的Activity数目
final ArrayList<ActivityRecord> mActivities = new ArrayList<ActivityRecord>();  //按照出现的先后顺序列出该任务中的所有Activity
#+END_SRC 
** 六、ActivityManagerService中一些重要的与调度相关的变量
- （1）记录最近启动的Activity，如果RAM容量较小，则记录的最大值为10个，否则为20个，超过该值后，Ams会舍弃最早记录的Activity
#+BEGIN_SRC csharp
static final int MAX_RECENT_TASKS = ActivityManager.isLowRamDeviceStatic() ? 10 : 20;
#+END_SRC 
- （2）当Ams通知应用程序启动（Launch）某个Activity时，如果超过10s，Ams就会放弃
#+BEGIN_SRC csharp
static final int PROC_START_TIMEOUT = 10*1000;
#+END_SRC 
- （3）当Ams启动某个客户进程后，客户进程必须在10s之内报告Ams自己已经启动，否则Ams会认为指定的客户进程不存在
#+BEGIN_SRC csharp
static final int PROC_START_TIMEOUT = 10*1000;
#+END_SRC 
- （4）等待序列：
  - 当Ams内部还没有准备好时，如果客户进程请求启动某个Activity，那么会被暂时保存到该变量中，
#+BEGIN_SRC csharp
final ArrayList<PendingActivityLaunch> mPendingActivityLaunches
    = new ArrayList<PendingActivityLaunch>();
#+END_SRC 
- （5）优先启动，其次再停止。进程A1包含两个Activity，启动顺序为A1->A2，当用户请求启动A2时，如果A1正在运行，Ams会先暂停A1，然后启动A2，当A2启动后再停止A1。
#+BEGIN_SRC csharp
private final ArrayList<TaskRecord> mRecentTasks = new ArrayList<TaskRecord>();
#+END_SRC 
** 七、startActivity()的流程(后面有详尽较好的讲解)
- 当用户单击某个应用图标后，执行程序会在该图标的onClick()事件中调用startActivity()方法，该方法会调用startActivityForResult()，在这个方法内部会调用Instrumentation对象的executeStartActivity()方法，每个Activity内部都有一个Instrumentation对象的引用，它就是一个管家，ActivityThread要创建或者暂停某个Activity都是通过它实现的。
- 流程图如下所示：
  
[[./pic/activityService_20220828_103648.png]]

* ActivityManagerService源码分析
- AMS是Android系统服务中很重要的一个，他负责四大组件的启动、切换、调度、生命周期的管理等等，接下来我们根据AMS的启动来分析AMS的源码
- AMS是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。
- AMS比较复杂，本章将带领读者按五条不同的线来分析它：
  - 1.       第一条线：同其他服务一样，将分析SystemServer中AMS的调用轨迹。
  - 2.       第二条线：以am命令启动一个Activity为例，分析应用进程的创建、Activity的启动，以及它们和AMS之间的交互等知识。
  - 3.       第三条线和第四条线：分别以Broadcast和Service为例，分析AMS中Broadcast和Service的相关处理流程。
  - 4.       第五条线：以一个Crash的应用进程为出发点，分析AMS如何打理该应用进程的身后事。
- AMS的家族图谱：
  
[[./pic/activityService_20220828_152742.png]]
- AMS由ActivityManagerNative（以后简称AMN）类派生，并实现Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口。而AMN由Binder派生，实现了IActivityManager接口。
- 客户端使用ActivityManager类。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。
** SystemServer启动AMS
- ActivityManagerService是在SystemServer.java中启动并注册的：
#+BEGIN_SRC csharp
private void startBootstrapServices() {

    // 启动AMS，见小节2.1
    mActivityManagerService = mSystemServiceManager.startService(
        ActivityManagerService.Lifecycle.class).getService();

    // 设置AMS
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);

    // 安装App安装器
    mActivityManagerService.setInstaller(installer);

    // 电源管理已经开启，在AMS中初始化PM，见小节3
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "InitPowerManagement");
    mActivityManagerService.initPowerManagement();
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);

    // 设置应用实例，在系统进程开始的时候，见小节4
    mActivityManagerService.setSystemProcess();
}
#+END_SRC 
- 看源码可以看到，startBootstrapServices中启动并注册了很多其他的服务，比如：PowerManagerService，DisplayManagerService，LightsService，PackageManagerService，UserManagerService，SensorService(native)，这写服务彼此之间有依赖，所以都放在startBootstrapServices方法里面
** 相对完整一点儿的SystemServer类的源码
#+BEGIN_SRC csharp
public final class SystemServer {
    // zygote的主入口
    public static void main(String[] args) {
        new SystemServer().run();
    }
    public SystemServer() {
        // Check for factory test mode.
        mFactoryTestMode = FactoryTest.getMode();
    }
    private void run() {
        // 加载本地系统服务库，并进行初始化
        System.loadLibrary("android_servers"); // <<<<<<<<<< jni:
        nativeInit();
        // 1、创建系统上下文
        createSystemContext();
        // 初始化SystemServiceManager对象，
        // 下面的系统服务开启都需要调用SystemServiceManager.startService(Class<T>)，这个方法通过反射来启动对应的服务
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        // 开启服务
        try { 
            startBootstrapServices(); // <<<<<<<<<<<<<<<<<<<< 
            startCoreServices();
            startOtherServices();
        } catch (Throwable ex) {
            Slog.e("System", "******************************************");
            Slog.e("System", "************ Failure starting system services", ex);
            throw ex;
        }
    }

    /*初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。
     *调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，
     *并调用了Application.onCreate()。 */
    private void createSystemContext() {
        ActivityThread activityThread = ActivityThread.systemMain(); // <<<<<<<<<< 
        mSystemContext = activityThread.getSystemContext();
        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);
    }

    // 在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。
    private void startBootstrapServices() {
        // 初始化ActivityManagerService
        mActivityManagerService = mSystemServiceManager.startService(
            ActivityManagerService.Lifecycle.class).getService();
        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);

        // 初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化
        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);
        // 初始化DisplayManagerService
        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);
        // 2、systemServer进程加载到AMS中，并被它管理
        mActivityManagerService.setSystemProcess();
    }
    private void startOtherServices() {
        // 3、将SettingProvider放到SystemServer进程中来运行
        mActivityManagerService.installSystemProviders();
        // 4、AMS是系统的核心服务，只有它准备好了，才能调用其他服务的SystemReady
        mActivityManagerService.systemReady(new Runnable() {
                @Override
                public void run() {
                    try {
                        startSystemUi(context); // 启动systemUi，如此，状态栏就准备好了
                    } catch (Throwable e) {
                        reportWtf("starting System UI", e);
                    }
                    Watchdog.getInstance().start(); // 启动watchdog
                }
            });
    }
}
#+END_SRC 
** 注册并启动
*** startService: 文件：SystemServiceManager.java
#+BEGIN_SRC csharp
public <T extends SystemService> T startService(Class<T> serviceClass) {
    try {
        final String name = serviceClass.getName();
        Slog.i(TAG, "Starting " + name);

        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartService " + name);
        // 创建服务:这个服务的类必须是SystemService的子类，于是我们需要传入带有ActivityManagerService的Lifecycle 
        if (!SystemService.class.isAssignableFrom(serviceClass)) {
            throw new RuntimeException("Failed to create " + name
                                       + ": service must extend " + SystemService.class.getName());
        }
        final T service;
        try {
            Constructor<T> constructor = serviceClass.getConstructor(Context.class);
            service = constructor.newInstance(mContext);
        } catch (InstantiationException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service could not be instantiated", ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service must have a public constructor with a Context argument", ex);
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service must have a public constructor with a Context argument", ex);
        } catch (InvocationTargetException ex) {
            throw new RuntimeException("Failed to create service " + name
                                       + ": service constructor threw an exception", ex);
        }
        // 注册
        mServices.add(service);
        // 开始服务
        try {
            service.onStart();
        } catch (RuntimeException ex) {
            throw new RuntimeException("Failed to start service " + name
                                       + ": onStart threw an exception", ex);
        }
        return service;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
}
#+END_SRC 
- 可以看出这方法的作用是创建并且开始一个服务，但是这个服务的类必须是SystemService的子类，于是我们需要传入带有ActivityManagerService的Lifecycle
*** Lifecycle: 文件：SystemServiceManager.java
#+BEGIN_SRC csharp
public static final class Lifecycle extends SystemService {
    private final ActivityManagerService mService;

    public Lifecycle(Context context) {
        super(context);
        // 构建一个新的AMS，见小节2.3
        mService = new ActivityManagerService(context);
    }
    @Override public void onStart() {
        // 开始服务，2.1中的service.onStart()调用的就是它，见小节2.4
        mService.start();
    }
    public ActivityManagerService getService() {
        return mService;
    }
}
#+END_SRC 
- 可以看出Lifecycle是继承SystemService的，并且在构造里构建了AMS，接下来我们来看看AMS的构建函数
*** AMS的构建函数
- 这个方法会在main thread中被唤醒，但是它需要通过各个handers和其他thread通信，所以要注意明确looper。该构造函数，里面是初始化一些变量，及创建了一些线程
#+BEGIN_SRC csharp
public ActivityManagerService(Context systemContext) {
    mContext = systemContext;
    mFactoryTest = FactoryTest.getMode();

    mSystemThread = ActivityThread.currentActivityThread();
    Slog.i(TAG, "Memory class: " + ActivityManager.staticGetMemoryClass());

    // 创建一个mHandlerThread线程，默认名是：ActivityManager，异步线程 [ServiceThread 与 HandlerThread 有什么不同 ？]
    mHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false /*allowIo*/);
    mHandlerThread.start();
    // 创建一个基于ActivityManager线程的Handler
    mHandler = new MainHandler(mHandlerThread.getLooper());

    // 创建一个UiHandler线程，是异步线程吗？
    mUiHandler = new UiHandler();

    // 用单例的方式创建一个名叫ActivityManager:kill的线程，并且创建一个killHandler
    if (sKillHandler == null) {
        sKillThread = new ServiceThread(TAG + ":kill",
                                        android.os.Process.THREAD_PRIORITY_BACKGROUND, true /* allowIo */);
        sKillThread.start();
        // 用于杀死进程
        sKillHandler = new KillHandler(sKillThread.getLooper());
    }

    // 构建一个可以延时10秒的前台广播队列
    mFgBroadcastQueue = new BroadcastQueue(this, mHandler,
                                           "foreground", BROADCAST_FG_TIMEOUT, false);
    // 构建一个可以延时60秒的普通广播队列(一定全都是后台广播吗？)
    mBgBroadcastQueue = new BroadcastQueue(this, mHandler,
                                           "background", BROADCAST_BG_TIMEOUT, true);
    mBroadcastQueues[0] = mFgBroadcastQueue; // 不故道这个数组的定义是在哪里，反正长度 >= 2
    mBroadcastQueues[1] = mBgBroadcastQueue;
    
    mServices = new ActiveServices(this);
    mProviderMap = new ProviderMap(this);
    mAppErrors = new AppErrors(mContext, this);

    // 新建一个data/system目录
    File dataDir = Environment.getDataDirectory();
    File systemDir = new File(dataDir, "system");
    systemDir.mkdirs();

    // 创建一个BatteryStatsService类
    mBatteryStatsService = new BatteryStatsService(systemDir, mHandler);
    // 把最新的数据写入硬盘
    mBatteryStatsService.scheduleWriteToDisk();
    mOnBattery = DEBUG_POWER ? true
        : mBatteryStatsService.getActiveStatistics().getIsOnBattery();
    mBatteryStatsService.getActiveStatistics().setCallback(this);

    // 创建进程统计服务类，并新建一个data/system/procstats目录
    mProcessStats = new ProcessStatsService(this, new File(systemDir, "procstats"));
    // 创建一个应用权限检查类，新建一个data/system/appops.xml文件，并注册对应的回调接口
    mAppOpsService = new AppOpsService(new File(systemDir, "appops.xml"), mHandler);
    mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null,
                                     new IAppOpsCallback.Stub() {
                                         @Override public void opChanged(int op, int uid, String packageName) {
                                             if (op == AppOpsManager.OP_RUN_IN_BACKGROUND && packageName != null) {
                                                 if (mAppOpsService.checkOperation(op, uid, packageName)
                                                     != AppOpsManager.MODE_ALLOWED) {
                                                     runInBackgroundDisabled(uid);
                                                 }
                                             }
                                         }
                                     });
    mGrantFile = new AtomicFile(new File(systemDir, "urigrants.xml"));

    // 创建多用户控制器，user 0是第一个，同时也是唯一开机过程中运行的用户
    mUserController = new UserController(this);

    // 获取OpenGL版本，如果没有找到，则默认为0
    GL_ES_VERSION = SystemProperties.getInt("ro.opengles.version",
                                            ConfigurationInfo.GL_ES_VERSION_UNDEFINED);

    mTrackingAssociations = "1".equals(SystemProperties.get("debug.track-associations"));
    // 设置系统的一些默认配置信息
    mConfiguration.setToDefaults();
    mConfiguration.setLocales(LocaleList.getDefault());
    mConfigurationSeq = mConfiguration.seq = 1;

    // 初始化进程CPU跟踪器
    mProcessCpuTracker.init();
    // 解析/data/system/packages-compat.xml文件，当设备屏幕大小不满足APK所需要的大小，
    // 则从packages-compat.xml都去尺寸，用兼容的方式运行
    mCompatModePackages = new CompatModePackages(this, systemDir, mHandler);

    // 根据AMS传入规则，过滤一些Intent
    mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), mHandler);

    // 用来管理Activity栈: 应试就是当系统有多个任务栈时，它们多任务栈的管理者，用于管理系统下存在的多个任务栈
    mStackSupervisor = new ActivityStackSupervisor(this);
    // 解释怎样启动Activity
    mActivityStarter = new ActivityStarter(this, mStackSupervisor);
    // 管理最近任务列表
    mRecentTasks = new RecentTasks(this, mStackSupervisor);

    // 创建一个统计 进程使用CPU情况 的线程，名叫CpuTracker
    mProcessCpuThread = new Thread("CpuTracker") {
        @Override
        public void run() {
            while (true) {
                try {
                    try {
                        synchronized(this) {
                            final long now = SystemClock.uptimeMillis();
                            long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;
                            long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;
                            //Slog.i(TAG, "Cpu delay=" + nextCpuDelay
                            //        + ", write delay=" + nextWriteDelay);
                            if (nextWriteDelay < nextCpuDelay) 
                                nextCpuDelay = nextWriteDelay;
                            if (nextCpuDelay > 0) {
                                mProcessCpuMutexFree.set(true);
                                this.wait(nextCpuDelay);
                            }
                        }
                    } catch (InterruptedException e) {
                    }
                    updateCpuStatsNow();
                } catch (Exception e) {
                    Slog.e(TAG, "Unexpected exception collecting process stats", e);
                }
            }
        }
    };
    // watchdog添加对AMS的监控
    Watchdog.getInstance().addMonitor(this);
    Watchdog.getInstance().addThread(mHandler);
}
#+END_SRC 
- 这个方法会在main thread中被唤醒，但是它需要通过各个handers和其他thread通信，所以要注意明确looper。该构造函数，里面是初始化一些变量，及创建了一些线程，大部分我都进行了注释。
*** start: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
private void start() {
    // 移除所有的进程组
    Process.removeAllProcessGroups();
    // 开始监控进程的CPU使用情况
    mProcessCpuThread.start();
    // 注册电池统计服务
    mBatteryStatsService.publish(mContext);
    // 注册应用权限检测服务
    mAppOpsService.publish(mContext);
    Slog.d("AppOps", "AppOpsService published");
    // 注册LocalService服务
    LocalServices.addService(ActivityManagerInternal.class, new LocalService());
}
#+END_SRC 
- 启动ProcessCpuThread，注册电池统计服务，应用权限检测服务和LocalService，其中LocalService继承了ActivityManagerInternal。
- 小结：创建AMS，启动AMS
** 初始化PM: initPowerManagement: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
public void initPowerManagement() {
    // Activity堆栈管理器和电池统计服务初始化PM
    mStackSupervisor.initPowerManagement();
    mBatteryStatsService.initPowerManagement();
    mLocalPowerManager = LocalServices.getService(PowerManagerInternal.class);
    PowerManager pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "*voice*");
    // 该唤醒锁为不计数锁，即无论acquire()多少次，一次release()就可以解锁
    mVoiceWakeLock.setReferenceCounted(false);
}
#+END_SRC 
- 小结：这主要是在AMS中初始化PM
** 设置应用实例
***  setSystemProcess: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
public void setSystemProcess() {
    try {
        // 以下都是想ServiceManager注册服务
        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); // 注册AMS自己
        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); // 注册进程统计服务
        ServiceManager.addService("meminfo", new MemBinder(this)); // 注册内存信息的服务
        ServiceManager.addService("gfxinfo", new GraphicsBinder(this)); // 注册输出渲染信息的服务
        ServiceManager.addService("dbinfo", new DbBinder(this)); // 注册输出数据库信息的服务
        // MONITOR_CPU_USAGE默认为true
        if (MONITOR_CPU_USAGE) {
            ServiceManager.addService("cpuinfo", new CpuBinder(this)); // 输出进程使用CPU的情况
        }
        ServiceManager.addService("permission", new PermissionController(this)); // 注册权限管理
        ServiceManager.addService("processinfo", new ProcessInfoService(this)); // 注册进程信息

        // 查询名为android的应用信息
        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(
            "android", STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);
        // 调用installSystemApplicationInfo ，见小节4.2
        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());

        synchronized (this) {
            // 创建一个ProcessRecord对象 ，见小节4.5
            ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
            app.persistent = true;
            app.pid = MY_PID;
            app.maxAdj = ProcessList.SYSTEM_ADJ;
            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.put(app.pid, app);
            }
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(
            "Unable to find android system package", e);
    }
}
#+END_SRC 
*** installSystemApplicationInfo: 文件：ActivityThread.java
#+BEGIN_SRC csharp
public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) {
    synchronized (this) {
        // 看SystemService中创建的ContextIml的installSystemApplicationInfo，见小节4.3
        getSystemContext().installSystemApplicationInfo(info, classLoader);
        // give ourselves a default profiler
        mProfiler = new Profiler();
    }
}
#+END_SRC 
*** ContextIml.installSystemApplicationInfo:文件：ContextImpl.java
#+BEGIN_SRC csharp
void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) {
    // 调用的是LoadeApk里面的installSystemApplicationInfo，见小节4.4
    mPackageInfo.installSystemApplicationInfo(info, classLoader);
}
#+END_SRC 
*** LoadeApk.installSystemApplicationInfo: 文件：LoadeApk.java
#+BEGIN_SRC csharp
void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) {
    // 断言只有packageName为android才能使用
    assert info.packageName.equals("android");
    mApplicationInfo = info;
    mClassLoader = classLoader;
}
#+END_SRC 
- 将ApplicationInfo加入到LoadeApk中，因为SystemService创建LoadeApk时，PKMS并没有完成对手机中文件的解析
*** AMS进程管理: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
synchronized (this) {
    // 调用进程管理函数，见4.6
    ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
    app.persistent = true;
    app.pid = MY_PID;
    app.maxAdj = ProcessList.SYSTEM_ADJ;
    // 将SystemServer对应的ApplicationThread保存到ProcessRecord中
    app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
    synchronized (mPidsSelfLocked) {
        // 根据ProcessRecord的pid，将ProcessRecord存在mPidsSelfLocked中
        mPidsSelfLocked.put(app.pid, app);
    }
    updateLruProcessLocked(app, false, null);
    updateOomAdjLocked();
}
#+END_SRC 
*** newProcessRecordLocked: 文件：ActivityManagerService.java
#+BEGIN_SRC csharp
final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess,
        boolean isolated, int isolatedUid) {
    String proc = customProcess != null ? customProcess : info.processName;
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    final int userId = UserHandle.getUserId(info.uid);
    int uid = info.uid;
    // isolated为false
    if (isolated) {
            }
    // 创建一个进程记录对象，见小节4.7
    final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
    // 判断是否为常驻的进程
    if (!mBooted && !mBooting
            && userId == UserHandle.USER_SYSTEM
            && (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK) {
        r.persistent = true;
    }
    // 将ProcessRecord保存在AMS里的mProcessNames里
    addProcessNameLocked(r);
    return r;
}
#+END_SRC 
*** ProcessRecord: 文件：ProcessRecord.java
#+BEGIN_SRC csharp
ProcessRecord(BatteryStatsImpl _batteryStats, ApplicationInfo _info,
        String _processName, int _uid) {
    mBatteryStats = _batteryStats;
    info = _info;
    isolated = _info.uid != _uid;
    uid = _uid;
    userId = UserHandle.getUserId(_uid);
    processName = _processName;
    pkgList.put(_info.packageName, new ProcessStats.ProcessStateHolder(_info.versionCode));
    maxAdj = ProcessList.UNKNOWN_ADJ;
    curRawAdj = setRawAdj = ProcessList.INVALID_ADJ;
    curAdj = setAdj = verifiedAdj = ProcessList.INVALID_ADJ;
    persistent = false;
    removed = false;
    lastStateTime = lastPssTime = nextPssTime = SystemClock.uptimeMillis();
}
#+END_SRC 
- 这主要是保存一些ProcessRecord里面的属性。
- 小结：
  - 第四节的主要作用就是将一些服务注册到ServiceManger中，包括AMS自己；然后将framework-res-.apk中applicationInfo信息加入到SystemServeice生成的LoadedApk中，同时构建SystemService对应的ProcessRecord，最后通过addProcessNameLocked(r)来把SystemService加入AMS的管理中来。
* 这一小部分，感觉和自己所掌握的远程服务绑定基础，讲解得很透彻
- AMS(ActivityManagerService)是贯穿Android系统组件的核心服务，负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作。因此想要了解Android的内部工作机制，就必须先了解�AMS的工作原理。在本文中，我将尽可能用通俗的语言去描述AMS涉及到的知识点帮助大家理解。
- 先梳理一下这个远程服务它所管理纪录着的几样对它来说狠重要的内容类别： 
- AMS提供了一个ArrayList mHistory来管理所有的activity，activity在AMS中的形式是ActivityRecord，task在AMS中的形式为TaskRecord，进程在AMS中的管理形式为ProcessRecord。如下图所示
  
[[./pic/activityService_20220828_165105.png]]
  -     从图中我们可以看出如下几点规则：
  -     1. 所有的ActivityRecord会被存储在mHistory管理；
  -     2. 每个ActivityRecord会对应到一个TaskRecord，并且有着相同TaskRecord的ActivityRecord在mHistory中会处在连续的位置；
  -     3. 同一个TaskRecord的Activity可能分别处于不同的进程中，每个Activity所处的进程跟task没有关系；
  -     因此，在分析Activity管理之前，先了解一下这个规则。
** AMS的内部实现
*** AMS原理模型
**** 1. ActivityManager
     #+BEGIN_SRC text
/frameworks/base/core/java/android/app/ActivityManager.java
     #+END_SRC 
- *ActivityManager* 是 *客户端* 用来 *管理系统中正在运行的所有Activity包括Task、Memory、Service等信息的工具* 。但是 *这些信息的维护工作却不是又ActivityManager负责的。在ActivityManager中有大量的get()方法，那么也就说明了他只是提供信息给AMS，由AMS去完成交互和调度工作。*
**** 2. AMS
     #+BEGIN_SRC text
/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
     #+END_SRC 
- AMS是作为 *管理Android系统组件的核心服务* ，他在 *SystemServer执行run()方法的时候被创建，并运行在独立的进程中* 。具体来说就是 *SystemServer管理着Android中所有的系统服务，这些系统服务的生命周期回调都由SystemServer去调度负责。*
#+BEGIN_SRC csharp
private void startBootstrapServices() {
    Installer installer = mSystemServiceManager.startService(Installer.class);

    // Activity manager runs the show.
    mActivityManagerService = mSystemServiceManager.startService(
            ActivityManagerService.Lifecycle.class).getService();
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    mActivityManagerService.setInstaller(installer);
}
#+END_SRC 
- 在 *SystemServer调用run()方法中开启必要的系统服务，并将这些服务注册和添加到管理列表中，并执行这些服务在进程中的生命周期* 。ActivityManagerService作为一个重要的核心服务就是在这里被初始成功的。
** AMS与ActivityManager的通信实现
   - 我们知道 *AMS和ActivityManager之间通信需要利用Binder来完成(跨进程远程服务绑定)* ，那么我们接下来分析一下这个通信机制是如何实现的。
- *ActivityManagerNative(AMN)中实现的代码是运行在Android应用程序的进程空间内，可直接使用的对象，Intent会由应用程序通过这个类将方法对应的Binder命令发送出去* 。
- 那么上面这一句话，是否可以理解为，是AWS在安卓应用层的客户端呢？在一个安卓系统中，会有几个这样的客户端，还是唯一的呢？
- ActivityManagerNative(AMN)是一个抽象的类，他包含了如下特点：
  - （1）继承Binder类
      - （2）实现IActivityManager接口
- 由于 *继承了Binder类，他就拥有了远程通信的条件。*
- *实现了IActivityManager接口，他能够得到ActivityManager管理关于内存、任务等内部信息* 。那么AMS作为AMN的子类也就自然享有了这些特性。
- 我们再回过头来看看 *ActivityManager中的方法是如何被调用的* ，举个栗子：
   #+BEGIN_SRC csharp
public List<ActivityManager.AppTask> getAppTasks() {
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) { // <<<<<<<<<< 
        throw e.rethrowFromSystemServer();
    }
// 上面可以得到 appTasks值，再怎么稍微转化一下成为tasks, 并返回
    return tasks;
}
   #+END_SRC 
- 我们在代码中发现，类似的get()方法的调用逻辑都是 *先通过ActivityManagerNative.getDefault()来获得ActivityManager的代理接口对象* 。getDefault()到底做了什么？
#+BEGIN_SRC csharp
/**
 * Retrieve the system's default/global activity manager.
 */
static public IActivityManager getDefault() {
    return gDefault.get();
}
private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {
    protected IActivityManager create() {
        IBinder b = ServiceManager.getService("activity");
        if (false) {
            Log.v("ActivityManager", "default service binder = " + b);
        }
        IActivityManager am = asInterface(b);
        if (false) {
            Log.v("ActivityManager", "default service = " + am);
        }
        return am;
    }
};
#+END_SRC 
- *ServiceManager是系统提供的服务管理类，所有的Service都通过他被注册和管理* ，并且 *通过getService()方法能够得到ActivityManager与AMS的远程通信Binder对象。*
- 在模块化设计里，前两天刚学习的BinderPool类通过管理所有多个模块化的远程服务的IBinder来对这些远程服务绑定统一管理，感觉很类似
#+BEGIN_SRC csharp
/**
 * Cast a Binder object into an activity manager interface, generating
 * a proxy if needed.
 */
static public IActivityManager asInterface(IBinder obj) {
    if (obj == null) {
        return null;
    }
    IActivityManager in =
        (IActivityManager)obj.queryLocalInterface(descriptor); // <<<<<<<<<< 
    if (in != null) {
        return in;
    }
    return new ActivityManagerProxy(obj); // <<<<<<<<<< 
}
#+END_SRC 
    - *得到了AMS的Binder对象之后，也就相当于拿到了与ActivityManager远程通信的许可证(句柄，接下来就可以调用其所定义的远程方法了)* 。接着， *在asInterface()这个方法中，这个许可证的使用权利被移交给了ActivityManagerProxy，那么ActivityManagerProxy就成为了ActivityManager与AMS远程通信的代理。*
- *ActivityManagerProxy也实现了IActivityManager接口* 。 *当客户端（ActivityManager）发起向服务端（AMS）的远程请求时，客户端提供的数据参数信息被封装打包，然后由ActivityManager的远程通信binder对象通过transact()方法把数据提交，然后再把数据写出返回给binder对象。*
#+BEGIN_SRC csharp
public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,
                         String resolvedType, IBinder resultTo, String resultWho, int requestCode,
                         int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(callingPackage);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo);
    data.writeString(resultWho);
    data.writeInt(requestCode);
    data.writeInt(startFlags);
    if (profilerInfo != null) {
        data.writeInt(1);
        profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
    } else {
        data.writeInt(0);
    }
    if (options != null) {
        data.writeInt(1);
        options.writeToParcel(data, 0);
    } else {
        data.writeInt(0);
    }
    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
#+END_SRC 
- 通过这种方式，AMS在自己的进程中就能获得ActivityManager进程发来的数据信息，从而完成对于Android系统组件生命周期的调度工作。
- https://blog.csdn.net/yueliangniao1/article/details/7227165?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-7227165-blog-8891414.topnsimilarv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-7227165-blog-8891414.topnsimilarv1&utm_relevant_index=10 上面这个讲到了活动启动模式以及任务栈和活动在不同栈中的迁移，感觉讲到了很多细节，明天早上再仔细看一遍
- Windows上的截图是一个被我放了很久的bug,没能安排好时间占用了早上最宝贵的时间来修改，有点儿可惜，但过程中在需要的时候一定能够解决自己的应用便利需要，并解决过程中所遇到的一切问题，包括用键的一再精简与优化，snipaste截图截出的图过浅等问题，还是很开心的。因为使用powershell来拿到Windows系统的剪贴板，可能具备wsl ubuntu emacs中使用的能力，但是Ubuntu中暂时保留一个简炼启动快的版本，暂时不再配置
- 晚上会动动笔，写或总结一些基础算法题；希望早上或白天的时间都能够用来深入学习安卓系统
* PackageManagerService
- 它是Android系统中最常用的服务之一。它负责系统中Package的管理，应用程序的安装、卸载、信息查询等。
- 它的一家老小：
      
[[./pic/activityService_20220828_151856.png]]
- 分析上图：
  - 1.IPackageManager接口类中定义了服务端和客户端通信的业务函数，还定义了内部类Stub，该类从Binder派生并实现了IPackageManager接口。
  - 2.PackageManagerService继承自IPackageManager.Stub类，由于Stub类从Binder派生，因此 *PackageManagerService将作为服务端参与Binder通信。*
  - 3.Stub类中定义了一个内部类Proxy，该类有一个IBinder类型（实际类型为BinderProxy）的成员变量mRemote， *mRemote用于和服务端PackageManagerService通信。*
  - 4.IPackageManager接口类中定义了许多业务函数，但是出于安全等方面的考虑，Android对外（即SDK）提供的只是一个子集，该子集被封装在抽象类PackageManager中。客户端一般通过Context的getPackageManager函数返回一个类型为PackageManager的对象，该对象的实际类型是PackageManager的子类ApplicationPackageManager。这种基于接口编程的方式，虽然极大降低了模块之间的耦合性，却给代码分析带来了不小的麻烦。
  - 5.ApplicationPackageManager类继承自PackageManager类。它并没有直接参与Binder通信，而是通过mPM成员变量指向一个IPackageManager.Stub.Proxy类型的对象。
- PKMS构造函数的主要功能是，扫描Android系统中几个目标文件夹中的APK，从而建立合适的数据结构以管理诸如Package信息、四大组件信息、权限信息等各种信息。抽象地看，PKMS像一个加工厂，它 *解析实际的物理文件（APK文件）以生成符合自己要求的产品。*
** PKMS工作流程
   
[[./pic/activityService_20220828_151939.png]]
- PKMS构造函数的工作流程大体可分三个阶段：
  - ·  扫描目标文件夹之前的准备工作。
  - ·  扫描目标文件夹。
  - ·  扫描之后的工作。
- 该函数涉及到的知识点较多，代码段也较长，因此我们将通过分段讨论的方法，集中解决相关的重点问题。
** 扫描目标文件夹之前的准备工作
*** 设置setting
- 进入PKMS构造函数，就会遇到第一个较为复杂的数据结构Setting及它的addSharedUserLPw函数。Setting的作用是管理Android系统运行过程中的一些设置信息，包括：字符串“android.uid.system“，UID（用户ID，），用于标识系统Package的FLAG_SYSTEM标志。
*** 扫描文件夹并解析xml文件
- 创建一个Installer对象，同时并解析对应的xml文件。包括：权限，包信息等。
- PKMS将扫描以下几个目录。
  - 1. */system/frameworks* ：该目录中的文件都是系统库，例如framework.jar、services.jar、framework-res.apk。不过scanDirLI只扫描APK文件，所以framework-res.apk是该目录中唯一“受宠”的文件。
  - 2. */system/app* ：该目录下全是默认的系统应用，例如Browser.apk、SettingsProvider.apk等。
  - 3. */vendor/app* ：该目录中的文件由厂商提供，即厂商特定的APK文件，不过目前市面上的厂商都把自己的应用放在 */system/app* 目录下。
- 下面总结一下Package扫描的流程:
  - scanDirLI用于对指定目录下的APK文件进行扫描。
  - 扫描完APK文件后，Package的私有财产就充公了。PKMS提供了好几个重要数据结构来保存这些财产：
    
[[./pic/activityService_20220828_152005.png]]
*** 构造函数分析之扫尾工作
- 这部分任务比较简单，就是将第二阶段收集的信息再集中整理一次，比如汇总并更新和Permission相关的信息，将信息写到package.xml、package.list及package-stopped.xml文件中。
** PKM的install
- 故事从adbinstall开始。
*** adb install分析
- 找到apk的目录位置，把相关信息发送给指定的Verification程序（另外一个APK），由它对要安装的APK进行检查（Verify）。
- 然后开始调用pm_command开始后续工作。
*** 调用pm_command进行安装
- 在编译system.image时，Android.mk中会将该脚本复制到system/bin目录下。从pm脚本的内容来看，它就是通过app_process执行pm.jar包的main函数。app_process是一个Native进程，它通过创建虚拟机启动了Zygote，从而转变为一个Java进程。实际上，app_process还可以通过类似的方法（即先创建Dalvik虚拟机，然后执行某个类的main函数）来转变成其他Java程序。
- Pm解析参数后，最终通过PKMS的Binder客户端调用 *installPackageWithVerification* 以完成后续的安装工作。
- installPackageWithVerification函数倒是蛮清闲，检查下权限，然后简简单单创建几个对象，发送INIT_COPY消息给mHandler，就甩手退出了。
- 在mHandler中APK的安装居然需要使用另外一个APK提供的服务，该服务就是DefaultContainerService，由DefaultCotainerService.apk提供。
- 相关类的一家子：
  
[[./pic/activityService_20220828_152141.png]]
- HandlerParams和InstallArgs均为抽象类。
- *HandlerParams有三个子类，分别是InstallParams、MoveParams和MeasureParams* 。其中，InstallParams用于处理APK的安装，MoveParams用于处理某个已安装APK的搬家请求（例如从内部存储移动到SD卡上），MeasureParams用于查询某个已安装的APK占据存储空间的大小（例如在设置程序中得到的某个APK使用的缓存文件的大小）。
-  对于 *InstallParams* 来说，它 *还有两个伴儿，即InstallArgs的派生类FileInstallArgs和SdInstallArgs* 。其中，FileInstallArgs针对的是安装在内部存储的APK，而SdInstallArgs针对的是那些安装在SD卡上的APK。
- 在mhandler中处理请求：
  - 1.调用DCS的getMinimalPackageInfo函数，将得到一个PackageLite对象，该对象是一个轻量级的用于描述APK的结构（相比PackageParser.Package来说）。在这段代码逻辑中，主要想取得其recommendedInstallLocation的值。此值表示该APK推荐的安装路径。
    - 具体步骤：通过用户在Settings数据库中设置的安装位置。检查外部存储或内部存储是否有足够空间。
  - 2.调用installLocationPolicy检查推荐的安装路径。例如系统Package不允许安装在SD卡上。
  - 3.createInstallArgs将根据安装位置创建不同的InstallArgs。如果是内部存储，则返回FileInstallArgs，否则为SdInstallArgs。
  - 4.在正式安装前，应先对该APK进行必要的检查。
  - 5.调用InstallArgs的copyApk。
- 调用PKMS的installPackageLI函数进行APK安装，该函数内部将调用InstallArgs的doRename对临时文件进行改名。另外，还需要扫描此APK文件。
- 该APK已经安装完成（不论失败还是成功），继续向mHandler抛送一个 *POST_INSTALL* 消息，该消息携带一个token，通过它可从mRunningInstalls数组中取得一个PostInstallData对象
- 在接收到POST_INSTALL消息之后，发送 *PACKAGE_ADDED* 广播。
*** APK 安装流程总结
- APK的安装流程竟然如此复杂，其目的无非是 *让APK中的私人财产公有化。*
  
[[./pic/activityService_20220828_152408.png]]
- 1.安装APK到内部存储空间这一工作流程涉及的主要对象包括：PKMS、DCS、InstallParams和FileInstallArgs。
- 2.此工作流程中每个对象涉及到的关键函数。
- 3.对象之间的调用通过虚线表达，调用顺序通过①②③等标明。

* ActivityManagerService: 今天早上再读，才觉得这篇讲得深入又浅显易懂，赶快收藏
- AMS是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。
- AMS比较复杂，本章将带领读者按五条不同的线来分析它：
  - 1.第一条线：同其他服务一样，将分析SystemServer中AMS的调用轨迹。
  - 2.第二条线：以am命令启动一个Activity为例，分析应用进程的创建、Activity的启动，以及它们和AMS之间的交互等知识。
  - 3.第三条线和第四条线：分别以Broadcast和Service为例，分析AMS中Broadcast和Service的相关处理流程。
  - 4.第五条线：以一个Crash的应用进程为出发点，分析AMS如何打理该应用进程的身后事。
** AMS的家族图谱：
   
[[./pic/activityService_20220829_081607.png]]
- AMS由ActivityManagerNative（以后简称AMN）类派生，并实现Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口。而 *AMN由Binder派生，实现了IActivityManager接口。*
- *客户端使用ActivityManager类* 。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。 *在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。*
** AMS的调用轨迹
- AMS由SystemServer的ServerThread线程创建，它的调用轨：
  - 1.调用main函数，得到一个Context对象
  - 2.将SystemServer进程可加到AMS中，并被它管理
  - 3.将ActivityManagerService的SettingsProvider放到SystemServer进程中来运行。
  - 4.在内部保存WindowManagerService（以后简称WMS）
*** 1.Main中的调用
- 1.创建AThread线程。
- 2.ActivityThread.systemMain函数。初始化ActivityThread对象。
- 3.ActivityThread.getSystemContext函数。用于获取一个Context对象，从函数名上看，该Context代表了System的上下文环境。
- 4.AMS的startRunning函数。
**** 步骤1：创建AThread线程
- 虽然AMS的main函数由ServerThread线程调用，但是AMS自己的工作并没有放在ServerThread中去做，而是新创建了一个线程，即AThread线程。其主要工作就是创建AMS对象，然后通知AMS的main函数。
- AMS构造函数的工作：
  - 创建BSS、USS、mProcessStats （ProcessStats类型）、mProcessStatsThread线程，这些都与系统运行状况统计相关。
  - 创建/data/system目录，为mCompatModePackages（CompatModePackages类型）和mConfiguration（Configuration类型）等成员变量赋值。
**** 步骤2：ActivityThread.systemMain函数。初始化ActivityThread对象
- 它 *ActivityThread代表一个应用进程的主线程* （ *对于应用进程来说，ActivityThread的main函数确实是由该进程的主线程执行* ），其职责就是调度及执行在该线程中运行的四大组件。
- *应用进程* 指那些 *运行APK的进程，它们由Zyote 派生（fork）而来，上面运行了dalvik虚拟机* 。与应用进程相对的就是 *系统进程（包括Zygote和SystemServer）* 。
- 前面所说的 *ActivityThread代表应用进程* （其上运行了APK）的主线程，而 *SystemServer并非一个应用进程* ，那么为什么此处也需要ActivityThread呢？
  - 还记得在 *PackageManagerService分析中提到的framework-res.apk* 吗？ *这个APK除了包含资源文件外，还包含一些Activity（如关机对话框），这些Activity实际上运行在SystemServer进程中。从这个角度看，SystemServer是一个特殊的应用进程。*
  - *通过ActivityThread可以把Android系统提供的组件之间的交互机制和交互接口（如利用Context提供的API）也拓展到SystemServer中使用。*
- 调用systemMain函数结束后：
  - 1.得到一个ActivityThread对象，它代表应用进程的主线程。
  - 2.得到一个Context对象，它背后所指向的Application环境与framework-res.apk有关。
- *systemMain函数将为SystemServer进程搭建一个和应用进程一样的Android运行环境。*
**** 步骤3：ActivityThread.getSystemContext函数。用于获取一个Context对象，从函数名上看，该Context代表了System的上下文环境。
- 调用该函数后，将得到一个代表系统进程的Context对象。
  
[[./pic/activityService_20220829_082224.png]]
**** 步骤4：AMS的startRunning函数。
- 就是调用startRunning
**** 总结：
- AMS的main函数的目的有两个：
  - 1.首先也是最容易想到的目的是创建AMS对象。
  - 2.另外一个目的比较隐晦，但是非常重要，那就是创建一个供SystemServer进程使用的Android运行环境。

*** 2.AMS的setSystemProcess(将SystemServer进程可加到AMS中，并被它管理)
**** 调用ActivityThread的installSystemApplicationInfo函数
- installSystemApplicationInfo函数的参数为一个ApplicationInfo对象，该对象由AMS通过Context查询PKMS中一个名为“android”的package得来，目的仅仅是为了创建一个Android运行环境。
- 由于framework-res.apk是一个APK文件，和其他APK文件一样，它应该运行在一个进程中。而 *AMS是专门用于进程管理和调度的* ，所以运行APK的进程应该在AMS中有对应的管理结构。因此 *AMS下一步工作就是将这个运行环境和一个进程管理结构对应起来并交由AMS统一管理。*
**** AMS对进程的管理
- AMS中的 *进程管理结构是ProcessRecord。*
  
[[./pic/activityService_20220829_082611.png]]
- 由上图可知：
  - 1. *ApplicationThreadNative实现了IApplicationThread接口* 。从该接口定义的函数可知， *AMS通过它可以和应用进程进行交互* ，例如，AMS启动一个Activity的时候会调用该接口的scheduleLaunchActivity函数。
  - 2. *ActivityThread通过成员变量mAppThread指向它的内部类ApplicationThread* ，而ApplicationThread从ApplicationThreadNative派生。
- *当AMS想要停止（stop）一个Activity时，会调用对应进程IApplicationThread Binder客户端的scheduleStopActivity函数* 。该函数 *服务端* 实现的就是 *向(客户端应用的)ActivityThread所在线程发送一个消息* 。在 *应用进程(客户端中)中，ActivityThread运行在主线程中，所以这个消息最终在主线程被处理。*
- *ProcessRecord* 除 *保存的信息包括：*  和 *与应用进程通信的IApplicationThread对象* 外，还保存了 *进程名* 、不同状态对应的 *Oom_adj* 值及一个 *ApplicationInfo* 。一个进程虽然可运行多个Application，但是 *ProcessRecord一般保存该进程中先运行的那个Application的ApplicationInfo。*
**** 保存该ProcessRecord对象
- AMS中有两个成员变量用于保存ProcessRecord，一个是 *mProcessNames* ，另一个是 *mPidsSelfLocked* ，如下图所示为这两个成员变量的数据结构示意图。
  
[[./pic/activityService_20220829_083053.png]]
- 仔细看上面的图，是不是至少有一处地方(uid vs pid)写错了？我觉得两个要么都是uid要么都是pid才对？
**** AMS的setSystemProcess总结：
- 现在来总结回顾setSystemProcess的工作：
  - 1.注册AMS、meminfo、gfxinfo等服务到ServiceManager中。
  - 2. *根据PKMS(PackageManagerService)返回的ApplicationInfo初始化Android运行环境* ，并 *创建一个代表SystemServer进程的ProcessRecord，从此，SystemServer进程也并入AMS的管理范围内。*
 
*** 3.AMS的installSystemProviders(3.将ActivityManagerService的SettingsProvider放到SystemServer进程中来运行)
- SystemServer中很多Service都需要向settings数据库查询配置信息。为此，Android提供了一个SettingsProvider来帮助开发者。该Provider在SettingsProvider.apk中，installSystemProviders就会加载该APK并把SettingsProvider放到SystemServer进程中来运行。
- 这里AMS向PKMS查询满足要求的ProviderInfo，最重要的查询条件包括：进程名和进程uid。同时AMS对ContentProvider进行管理（这也是查询ProviderInfo的原因）。
 
**** ASM的systemReady
- 可以分为三个阶段的工作:
***** 第一阶段：
- 发送并处理与 *PRE_BOOT_COMPLETED* 广播相关的事情。 *该广播接收者的工作似乎和系统升级有关。(目前的工作案例中我还不曾涉及到这一块儿)*
***** 第二阶段：
- 1.杀死那些竟然在AMS还未启动完毕就先启动的应用进程。注意，这些应用进程一定是APK所在的Java进程，因为只有应用进程才会向AMS注册，而一般Native（例如mediaserver）进程是不会向AMS注册的。
- 2. *从Settings数据库中获取配置信息，目前只取4个配置参数* ，分别是："*debug_app*"（ /设置需要debug的app的名称/ ）、"*wait_for_debugger*"（ /如果为1，则等待调试器，否则正常启动debug_app/ ）、"*always_finish_activities*"（ /当一个activity不再有地方使用时，是否立即对它执行destroy/ ）、"*font_scale*"（ /用于控制字体放大倍数，这是Android 4.0新增的功能/ ）。
- 以上配置项由Settings数据库的System表提供。
- 附加：自己先前读 *安卓系统Settings源码的时候，它提供了四个缺省表，System，Default, Global, + ?*
***** 第三阶段：
- 1.调用systemReady设置的回调对象goingCallback的run函数。
  - 在run中，调用一些服务的systemReady函数和启动Watchdog。
- 2.启动那些声明了persistent的APK。persistent apk就是，在系统启动的时候就可以运行的apk.
#+begin_SRC xml
<application
    android:persistent="true|false">
</application>
#+END_SRC 
            - 在我们开发系统级的App时，很有可能就会用persistent属性。当在AndroidManifest.xml中将persistent属性设置为true时，那么该App就会具有如下两个特性：
              - 系统刚起来的时候，该App也会被启动起来
              - App被强制杀掉后，系统会重启该App。这种情况只针对系统内置的App，第三方安装的App不会被重启。
- 3.启动桌面，在Home启动成功后，AMS才发送 *ACTION_BOOT_COMPLETED* 广播(这个广播就是自己工作应用中经常会用到/会接听用于开机启动完成后应用必要的优先配置等使用的广播了)
 
*** ActivityManagerService总结
- 1. *AMS的main函数* ： *创建AMS实例* ，其中最重要的工作是 *创建Android运行环境，得到一个ActivityThread和一个Context对象* 。
- 2. *AMS的setSystemProcess()函数* ：该函数 *注册AMS和meminfo等服务到ServiceManager中* 。另外， *它为SystemServer创建了一个ProcessRecord对象* 。由于 *AMS是Java世界的进程管理及调度中心，要做到对Java进程一视同仁，尽管SystemServer贵为系统进程，此时也不得不将其并入AMS的管理范围内。*
- 3. *AMS的installSystemProviders：* 为 *SystemServer加载SettingsProvider。*
- 4.AMS的 *systemReady* ：做 *系统启动完毕前最后一些扫尾工作。该函数调用完毕后，HomeActivity将呈现在用户面前。*
 
* am命令启动一个Activity
- am和pm一样，也是一个脚本，它用来和AMS交互，如启动Activity、启动Service、发送广播等。其核心文件在Am.java中。
- 下面附一个看见的参考图，但是不一定是用am来启动一个活动的
  
[[./pic/activityService_20220830_083145.png]]
** AMS的startActivityAndWait函数分析
** Task、Back Stack、ActivityStack及Launch mode
- 一个Acitivity的启动是由一个应用进程发起的，IApplicationThread是应用进程和AMS交互的通道，也可算是调用进程的标示。
- mMainStack为AMS的成员变量，类型为ActivityStack。他通过startActivityAndWait开始启动activity。
- 对多Task的情况来说，系统只支持一个处于前台的Task，即用户当前看到的Activity所属的Task，其余的Task均处于后台，这些后台Task内部的Activity保持顺序不变。用户可以一次将整个Task挪到后台或者置为前台。
- Task内部Activity的组织方式如下：
  
[[./pic/activityService_20220829_084557.png]]
- Android通过先入后出的方式来组织Activity。数据结构中的Stack即以这种方式工作。
- 为了应对多个Task的组织及管理方式，Android设计了一个ActivityStack类来负责上述工作。
  
[[./pic/activityService_20220829_084613.png]]
- *Activity由 /ActivityRecord/ 表示* ， *Task由 /TaskRecord/ 表示* 。ActivityRecord的task成员指向该Activity所在的Task。state变量用于表示该Activity所处的状态（包括INITIALIZING、RESUMED、PAUSED等状态）。
- ActivityStack用mHistory这个ArrayList保存ActivityRecord。 *令人大跌眼镜的是，该mHistory保存了系统中所有Task的ActivityRecord，而不是针对某个Task进行保存。*
  - 每每读到这种时候，小伙伴们就惊呆了：镜片掉了一地，隐形掉了一地，眼珠也掉了一地。。。。。
  - *ActivityStack的mMainStack* 成员比较有意思， *它代表此ActivityStack是否为主ActivityStack* 。有主必然有从，但是目前系统中只有一个ActivityStack，并且它的mMainStack为true。
  - 从ActivityStack的命名可推测，Android在开发之初也想用ActivityStack来管理单个Task中的ActivityRecord（在ActivityStack.java的注释中说过，该类为“ *State and management of a single stack of activities* ”），但不知何故，在现在的代码实现将所有Task的ActivityRecord都放到mHistory中了，并且依然保留mMainStack。
- *ActivityStack采用数组的方式保存所有Task的ActivityRecord(这里真的是数组吗？还是写错了？)* ，并且 *没有成员保存TaskRecord* 。
  - *这种实现方式少了TaskRecord一级的管理，直接以ActivityRecord为管理单元* 。这种做法 *能降低管理方面的开销。但是 缺点是弱化了Task的概念，结构不够清晰。*
- *启动模式* ：分别是 *standard、singleTop、singleTask和singleInstance* 。描述的是 *activity之间的关系。*
- *标志* ： *FLAG_ACTIVITY_NEW_TASK，FLAG_ACTIVITY_CLEAR_TASK，FLAG_ACTIVITY_CLEAR_TOP* 。描述的是 *Activity和Task关系的。*
** startActivityAndWait
- 该函数的目标是启动com.dfp.test.TestActivity，假设系统之前没有启动过该Activity，则
  - 1.由于在am中设置了FLAG_ACTIVITY_NEW_TASK标志，因此除了会创建一个新的ActivityRecord外，还会新创建一个TaskRecord。
  - 2.还需要启动一个新的应用进程以加载并运行com.dfp.test.TestActivity的一个实例。
  - 3.如果TestActivity不是Home，还需要停止当前正在显示的Activity。
*** 具体步骤：
- 1.首先需要通过PKMS查找匹配该Intent的ActivityInfo。
- 2.处理FLAG_CANT_SAVE_STATE的情况，但系统目前不支持此情况。
- 3.另外，获取调用者的pid和uid。由于本例的caller为null，故所得到的pid和uid均为am所在进程的uid和pid。
- 4.启动Activity的核心函数是startActivityLocked。
- 5.根据返回值做一些处理，因为目标Activity要运行在一个新的应用进程中，就必须等待那个应用进程正常启动并处理相关请求
** startActivityLocked主要工作
- 1.处理sourceRecord及resultRecord。其中，sourceRecord表示发起本次请求的Activity，resultRecord表示接收处理结果的Activity（启动一个Activity肯定需要它完成某项事情，当目标Activity将事情成后，就需要告知请求者该事情的处理结果）。 *在一般情况下，sourceRecord和resultRecord应指向同一个Activity* (这里这么写是故意误导弱弱们的吧？)。
- 2.处理app Switch。如果AMS当前禁止appswitch，则只能把本次启动请求保存起来，以待允许app switch时再处理。从代码中可知，AMS在处理本次请求前，会先调用doPendingActivityLaunchesLocked函数，在该函数内部将启动之前因系统禁止appswitch而保存的Pending请求。
- 3.调用startActivityUncheckedLocked处理本次Activity启动请求，为新创建的ActivityRecord找到一个合适的Task。
- *下面是来自另一处更变详尽的解释*
-  startActivityLocked()方法在创建ActivityRecord前，还做了如下几个操作：
    1. 确定sourceRecord和resultRecord，这两个变量均为ActivityRecord类型，前者代表请求启动当前activity的activity；后者表示当前的activity在启动之后需要返回结果的ActivityRecord，一般情况下，如果sourceRecord的activity使用startActivityForResult()启动当前activity并且requestCode>=0时，则resultRecord不为空，且resultRecord=sourceRecord。
       
[[./pic/activityService_20220829_094826.png]]
   - 还有一种特殊的情况，当启动一个activity时，启动的Intent设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT标志，在这种情况resultRecord并不指向sourceRecord，而是指向sourceRecord的sourceRecord，比较绕上个图先
     
[[./pic/activityService_20220829_094904.png]]
   - 如上图所示，Activity A 启动了Activity B，Activity B又启动了C，A-->B-->C, 这种情况下，A启动B要求B返回result给A，但是如果B在启动C时，Intent设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT标志，那么此时将会交由C向A setResult。为了避免冲突，B启动C时不得指定resultRecord>=0。
#+BEGIN_SRC csharp
ActivityRecord sourceRecord = null;  
ActivityRecord resultRecord = null;  
if (resultTo != null) {  
    int index = indexOfTokenLocked(resultTo);  
    if (DEBUG_RESULTS) Slog.v(  
        TAG, "Sending result to " + resultTo + " (index " + index + ")");  
    if (index >= 0) {  
        sourceRecord = (ActivityRecord)mHistory.get(index);  
        if (requestCode >= 0 && !sourceRecord.finishing)  
            resultRecord = sourceRecord;  
    }  
}  
int launchFlags = intent.getFlags();  
if ((launchFlags&Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0  
        && sourceRecord != null) {  
    // Transfer the result target from the source activity to the new  
    // one being started, including any failures.  
    if (requestCode >= 0) { 
        return START_FORWARD_AND_REQUEST_CONFLICT;  
    resultRecord = sourceRecord.resultTo;  
    resultWho = sourceRecord.resultWho;  
    requestCode = sourceRecord.requestCode;  
    sourceRecord.resultTo = null;  
    if (resultRecord != null) 
        resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);  
}
#+END_SRC 
** startActivityUncheckedLocked的分析：
- 步骤1：确定是否需要为新的Activity创建一个Task，即是否设置FLAG_ACTIVITY_NEW_TASK标志。
- 步骤2：找到一个合适的Task，然后对应做一些处理。
- 步骤3：根据条件判断使用原有的TaskRecord还是新建一个，并调用startActivityLocked函数进行处理。
- 步骤4：进行Activity之间的动画切换。
- 总结：首先创建ActivityRecord和TaskRecord并将ActivityRecord添加到mHistory末尾，然后调用resumeTopActivityLocked启动它。
** resumeTopActivityLocked分析
- 在当中mResumedActivity指向上一次启动的Activity，也就是当前界面显示的这个Activity，如果mHistory中没有要启动的Activity，则启动Home。
- （接startActivityUncheckedLocked的分析）如果该ActivityRecord已有对应的进程存在，则只需要重启Activity。此进程还不存在，所以要先创建一个应用进程,通过startProcessLocked。
** startProcessLocked分析
- 通过发送消息给Zygote以派生一个应用进程（应用进程）。
*** 应用进程的创建及初始化
- 应用进程的入口是ActivityThread的main函数，它是在主线程中执行的。
  - 1、在main函数内部将创建一个消息循环Loop，接着调用ActivityThread的attach函数，最终将主线程加入消息循环。
  - 2、AMS创建一个应用进程后，会设置一个超时时间（一般是10秒）。如果超过这个时间，应用进程还没有和AMS交互，则断定该进程创建失败。所以，应用进程启动后，需要尽快和AMS交互，即调用AMS的attachApplication函数。在该函数内部将调用attachApplicationLocked。
*** attachApplicationLocked分析
**** 第一步：
- *设置代表该应用进程的ProcessRecrod对象的一些成员变量* ，例如 *用于和应用进程交互的thread对象* 、 *进程调度优先级* 及 *oom_adj的值* 等。
- 从消息队列中撤销 *PROC_START_TIMEOUT_MSG* (这种超时机制在车载系统的双向信号传递控制器的信号下发中也是经常用到)。 
- 至此，该进程启动成功。
**** 第二步：
- 在generateApplicationProvidersLocked函数内部查询（根据进程名，uid确定）PKMS以获取需运行在该进程中的ContentProvider，为调用ApplicationThread的 *bindApplication* 做准备。
- 刚创建的这个进程并不知道自己的历史使命是什么，甚至连自己的进程名都不知道，只能设为"< *pre-initialized* >"。其实， *Android应用进程的历史使命是AMS在其启动后才赋予它的* ，这一点和我们理解的一般意义上的进程不太一样。根据之前的介绍， *Android的组件应该运行在Android运行环境中* 。 *创建应用进程这一步只是创建了一个能运行Android运行环境的容器* 。
- *bindApplication* 的功能就是 *创建并初始化位于该进程中的Android运行环境。*
**** 第三步：
应用进程已经准备好了Android运行环境， *接着将获取ActivityStack中一个需要运行的ActivityRecord并启动，最后通知应用进程启动Activity和Service等组件* ，其中 *用于启动Activity的函数是ActivityStack.realStartActivityLocked。*
 
*** ActivityStack的realStartActivityLocked分析
- 它里面有两个关键函数，分别是： *scheduleLaunchActivity和completeResumeLocked。*
  - scheduleLaunchActivity用于和应用进程交互，通知它启动目标Activity。
  - completeResumeLocked将继续AMS的处理流程。
**** scheduleLaunchActivity
- 它 *保存AMS发送过来的参数信息，向主线程发送消息* ，该消息的处理在 *handleLaunchActivity* 中进行。在其中 *根据ApplicationInfo得到对应的PackageInfo。*
- *通过Java反射机制创建目标Activity，将在内部完成Activity生命周期的前两步，即调用其onCreate和onStart函数* 。我们的目标com.dfp.test.TestActivity创建完毕。
- 调用 *handleResumeActivity* ，会 *在其内部调用目标Activity的onResume函数。*
**** completeResumeLocked
- AMS给了应用进程10秒的时间，希望它在10秒内调用activityIdle函数。这个时间不算长，和前面AMS等待应用进程启动的超时时间一样。
- 在activityIdle中设置了请求超时处理。并调用activityIdleInternal函数，处理被暂停的Activity。
- 如果 *被暂停的Activity处于finishing状态* （例如Activity在其onStop中调用了finish函数），则调用 *finishCurrentActivityLocked* 。否则，要调用 *stopActivityLocked* 处理暂停的Activity。
 
*** ApplicationThread的bindApplication分析
- 该函数将为应用进程绑定一个Application。
- *ApplicationThread* 接收到来自AMS的指令后，均会 *将指令中的参数封装到一个数据结构中* ，然后 *通过发送消息的方式转交给主线程去处理* 。 *BIND_APPLICATION* 最终将由 *handleBindApplication* 函数处理。
- bindApplication函数将设置一些初始化参数，其中最重要的有：
  - 1.为之前的无名进程设置进程名，并初始化参数
  - 2.创建一个Application对象，该对象是本进程中运行的第一个Application。
  - 3.如果该Application有ContentProvider，则应安装它们。
** 总结:
- 在应用进程启动后，需要尽快调用AMS的attachApplication函数，该函数是这个刚呱呱坠地的应用进程第一次和AMS交互。此时的它还默默“无名”，连一个确定的进程名都没有。不过没关系，attachApplication函数将根据创建该应用进程之前所保存的ProcessRecord为其准备一切“手续”。
- attachApplication准备好一切后，将调用应用进程的bindApplication函数，在该函数内部将发消息给主线程，最终该消息由handleBindApplication处理。handleBindApplication将为该进程设置进程名，初始化一些策略和参数信息等。另外，它还创建一个Application对象。同时，如果该Application声明了ContentProvider，还需要为该进程安装ContentProvider。
  
[[./pic/activityService_20220829_090302.png]]
** startActivity总结
- 1.行程的起点是am。am是Android中很重要的程序。我们利用amstart命令，发起本次目标Activity的启动请求。
- 2.接下来进入ActivityManagerService和ActivityStack这两个核心类。对于启动Activity来说，这段行程又可分细分为两个阶段：第一阶段的主要工作就是根据启动模式和启动标志找到或创建ActivityRecord及对应的TaskRecord；第二阶段工作就是处理Activity启动或切换相关的工作。
- 3.首先AMS直接创建目标进程并运行Activity的流程，其中涉及目标进程的创建，在目标进程中Android运行环境的初始化，目标Activity的创建以及触发onCreate、onStart及onResume等其生命周期中重要函数调用等相关知识点。
- 4.接着AMS先pause当前Activity，然后再创建目标进程并运行Activity的流程。其中牵扯到两个应用进程和AMS的交互，其难度之大可见一斑。


* task管理
** task和activity以及process整体的关系
- AMS提供了一个ArrayList mHistory来管理所有的activity，activity在AMS中的形式是ActivityRecord，task在AMS中的形式为TaskRecord，进程在AMS中的管理形式为ProcessRecord。如下图所示
  
[[./pic/activityService_20220829_095916.png]]
- 从图中我们可以看出如下几点规则：
  - 1. 所有的ActivityRecord会被存储在mHistory管理；
  - 2. 每个ActivityRecord会对应到一个TaskRecord，并且有着相同TaskRecord的ActivityRecord在mHistory中会处在连续的位置；
  - 3. 同一个TaskRecord的Activity可能分别处于不同的进程中，每个Activity所处的进程跟task没有关系；
- 因此，在分析Activity管理之前，先了解一下这个规则。
- 在android应用开发中，task是一个很重要的概念，在文章开始，我就画出了task和activity以及process整体的关系，在这里还需要说明一下，task和application的区别，
- application在android中的作用仅仅是activity在未被使用前的一个容器，我们开发android应用程序时，需要一个application来组织我们开发的activity，application和activity之间是一个静态关系，并且是一一对应的关系；也就是说我们开发的activity在PM中的最终形式是唯一的，永远对应一个application。
- 而task和activity之间的关系是动态的关系，是我们在运行应用程序时，activity的调用栈，同一个task中的activity可能来自不同的application。
** 1 Intent.FLAG_ACTIVITY_NO_USER_ACTION
- 检查Intent是否设置了Intent.FLAG_ACTIVITY_NO_USER_ACTION，如果设置了，则在activity pause之前将不再调用activity的onUserLeaveHint()方法。
#+BEGIN_SRC csharp
mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;  
if (DEBUG_USER_LEAVING) Slog.v(TAG, "startActivity() => mUserLeaving=" + mUserLeaving);  
#+END_SRC 
** 2 Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP
- 检查Intent是否设置了Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP，这个标志我有点困惑，从它的注释可以看出 *它的含义是指如果设置了该flag，那么mHistory中最top的activity在后续的处理中将不被视为top，而将前一个activity视为top，如A-->B-->C，将B视为top。*
- 这个top activity的作用很大，涉及到后面对task的处理。但是目前来看这个flag并没有起到该有的作用，代码中判断如果设置了该标志，那么AMS将会视当前正在启动的activity为top，然后去mHistory中去查找它的前一个activity为后续task处理的top activity(topRunningNonDelayedActivityLocked()中实现)，但是现在的问题是此时此刻，正在启动的activity并不存在于mHistory中，因为我们在前一个函数中刚刚创建了这个ActivityRecord。如下面代码所示：
#+BEGIN_SRC csharp
ActivityRecord notTop = (launchFlags&Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null;  
#+END_SRC 
- 因此，感觉这个flag的意义不是太大。
** 3 何时应该创建新的task
- sourceRecord为空；
- sourceRecord的activity的launch mode为ActivityInfo. *LAUNCH_SINGLE_INSTANCE* ，也就是sourceRecord activity的task只允许一个activity；
- 当前activity的launch mode为ActivityInfo. *LAUNCH_SINGLE_INSTANCE* 或者r.launchMode == ActivityInfo. *LAUNCH_SINGLE_TASK* 。
- *以上几种情况* ，均可视为需要为启动的activity创建一个新的task.
#+BEGIN_SRC csharp
if (sourceRecord == null) {  
// This activity is not being started from another...  in this  
// case we -always- start a new task.  
    if ((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {  
        Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "  
               + intent);  
        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;  
    }  
} else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {  
// The original activity who is starting us is running as a single  
// instance...  this new activity it is starting must go on its  
// own task.  
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;  
} else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE  
           || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {  
// The activity being started is a single instance...  it always  
// gets launched into its own task.  
    launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;  
}  
#+END_SRC 
** 4 Intent.FLAG_ACTIVITY_NEW_TASK时断开与Caller依赖
- 如果启动的activity需要新的task，那么新启动的activity将会与其caller断开依赖关系，这个关系主要是指result反馈，A-->B,如果A是通过startActivityForResult()请求启动的，并且requestCode >=0,那么如果B是在新的task中，那么B在finish的时候将不再向A反馈result，而是在启动过程中就会向A反馈一个RESULT_CANCELED。
#+BEGIN_SRC csharp
if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {  
// For whatever reason this activity is being launched into a new  
// task...  yet the caller has requested a result back.  Well, that  
// is pretty messed up, so instead immediately send back a cancel  
// and let the new task continue launched as normal without a  
// dependency on its originator.  
    Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");  
    sendActivityResultLocked(-1,  
                             r.resultTo, r.resultWho, r.requestCode,  
                             Activity.RESULT_CANCELED, null);  
    r.resultTo = null;  
}  
#+END_SRC 
** 5 Task复用
*** 5.1 Task的基本属性 
- 检查mHistory中是否有task可复用，在分析这段之前，先了解一下 *task的一些基本概念*
  - task的root activity是指如果一个activity启动时创建的了一个新的task，那么这个activity是task的root activity；
  - task.affinity是指root activity的affinity；
  - task.intent是指启动root activity的Intent；
  - task.affinityIntent是指activity在进行了TaskReparenting之后，AMS为activity分配了新的task，该task的affinityIntent则是启动该activity时的Intent，此时task.intent==null。
- TaskReparenting操作举例说明一下，假如有2个activity拥有不同的affinity，且自Activity A中启动Activity B，假如Activity A是所在task的root activity，如下图示：
  
[[./pic/activityService_20220829_101320.png]]
- 假如Activity B设置了ActivityInfo.FLAG_ALLOW_TASK_REPARENTING，那么如果此时另外一个application启动了Activity B并要求其在新的task中，那么此时的Activity B将被从Task A中移动到新的task中，如下图所示：
  
[[./pic/activityService_20220829_101333.png]]
- 这个过程就称之为TaskReparenting，关于TaskReparenting，我会专门写一篇文章分析一下。下面来分析task复用的过程。
*** 5.2 查找可复用的task
- 以下3种条件需要检查是否有有task可复用
#+BEGIN_SRC csharp
(launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &&
    (launchFlags&Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0;
r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
#+END_SRC 
- 第⑴是一个组合条件，Intent. *FLAG_ACTIVITY_MULTIPLE_TASK* 不能单独使用，它 *是和Intent.FLAG_ACTIVITY_NEW_TASK结合起来使用的* ， *如果设置了Intent.FLAG_ACTIVITY_MULTIPLE_TASK，那么将会永远启动一个新的task，不管是否有可复用的task。*
- 为什么是这3种条件，从android的开发文档中，我们可知LAUNCH_SINGLE_TASK和LAUNCH_SINGLE_INSTANCE两种launch mode的activity只允许作为task的root activity，既然是作为root activity，那么它所处的task的affinity必然是和它的是一样的，因此从mHistory中找打一个和自己的affinity相同的task是非常有必要的。
- 而对于设置了Intent.FLAG_ACTIVITY_NEW_TASK的Intent来说，并且没有设置Intent.FLAG_ACTIVITY_MULTIPLE_TASK，那么同样的，它也必须是作为它所处的task的root activity。道理是一样的。
**** AMS去mHistory中查找可复用的task，查找这个task的规则如下：    
***** ⑴ launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE的情况，遵循如下规则： @findTaskLocked()
- ① 查找mHistory中是否有与要启动的activity相同affinity的task，上面也提过这几类activity启动时，均是作为task的root activity，并且其task的affinity必须和自己的affinity相同，因此首先需要去mHistory查找和自己affinity相同的task。
- ② 如果activity没有affinity，即属性android:taskAffinity设置为“”，空字符串时。此时AMS就会去mHistory中去查找是否有task的root activity和启动的activity相同，通过比较 *task.intent.getComponent()* 和 *启动activity的Comeponent* 比较，为什么是root activity，前面分析过了；
- ③ 如果task.Intent为空，这种情况发生在TaskReparenting之后，TaskReparenting之后，AMS为这个activity创建一个新的task，并将启动这个activity的Intent赋值给task.affinityIntent，并且此时的task.Intent==null。此时就需要比较 *task.affinityIntent.getComponent()* 和 *启动activity的Comeponent* 比较，看是否和启动的activity相同。
- *以上3个规则中* ，均是返回找的task中最上面的activity，而不一定是task的activity，至于如何处理要启动的activity和task中已有的activity，后面会介绍。
***** ⑵ launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE的情况，遵循如下规则： @findActivityLocked()
- 对于ActivityInfo. *LAUNCH_SINGLE_INSTANCE* 启动模式来说， *它所处的task中只允许有它一个activity* ，因此它的规则只符合上面规则中的②二；
- 对于第①条，由于设置了ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity，它只能自己独处一个task，不可能和别人共享同一个task，因此mHistory即使存在了与该activity有相同的affinity的activity，如果这个activity和启动的activity不同，那么ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity也不可能和它共用一个task，因此这第①条完全可以不用检查。
- 对于第②条，由于该模式的activity独处一个task，因此完全没有可能所处的task的affinity和自己的affinity不同，因此，假如mHistory存在相同的activity与启动的activity相同，那么这个activity的affinity必然和自己的相同。所以对于这种模式，第②条囊括了其他模式的①②两条。
- 对于第③条，同样的道理，ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity不可能处在与自己不同affinity的task中，因此不可能出现TaskReparenting操作，所以这条也不需要。
#+BEGIN_SRC csharp
ActivityRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE  
    ? findTaskLocked(intent, r.info)  
    : findActivityLocked(intent, r.info);  
#+END_SRC 
- 在获得taskTop之后，下面来分析这个taskTop的意义。
*** 5.3 task移到mHistory前端
- 由于我们要复用task，因此需要将taskTop所在的task移到mHistory前端 。
#+BEGIN_SRC csharp
ActivityRecord curTop = topRunningNonDelayedActivityLocked(notTop);  
if (curTop.task != taskTop.task) {  
    r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);  
    boolean callerAtFront = sourceRecord == null  
        || curTop.task == sourceRecord.task;  
    if (callerAtFront) {  
// We really do want to push this one into the  
// user's face, right now.  
        moveTaskToFrontLocked(taskTop.task, r);  
    }  
}  
#+END_SRC 
*** 5.4 Reset Task
- 如果Intent设置Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，最常见的情况，当从Home启动应用程序时，会设置这个flag；从recently task进入应用程序，则不会设置这个falg。
- 设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，AMS会对复用的task作如下处理，下面称这个可复用的task为复用task：
**** 设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，AMS会对复用的task作如下处理
***** ⑴ mHistory中，对于复用task中的除root activity外的activity，有如下处理
- 在此之前，先介绍 *activity的几个关键属性：*
  - 一① 如果 *复用task在后台时间超过30min* ，那么 *在这个过程中将删除除root activity之外的所有的activity* ；
  - 二② 如果 *新启动的activity* 设置了属性ActivityInfo. *FLAG_ALWAYS_RETAIN_TASK_STATE* ，那么表明 *它并不要求后台20min的复用task删除activity；*
  - 三③ 如果 *新启动的activity* 设置了属性ActivityInfo. *FLAG_CLEAR_TASK_ON_LAUNCH* ，那么表明 *不论复用task在后台是否超过30min，一律要求删除除root activity之外的所有的activity；*
  - 四④ *复用task中的activity* 设置了属性ActivityInfo. *FLAG_FINISH_ON_TASK_LAUNCH* ，那么 *复用task从home中再次被启动到前台时，这个activity会被删除；*
  - 五⑤ *复用task中的activity* 设置了属性ActivityInfo. *FLAG_ALLOW_TASK_REPARENTIN* ，并且这个 *activity的resultTo为空* ，那么也就是说这个activity和它的caller没有依赖关系，那么AMS认为这个activity暂时没有用处了， *需要对其进行TaskReparenting操作，最好的方法是把它放到mHistory栈底，不影响其他task。*
  - 六⑥ *复用task中的activity* 的Intent设置属性Intent. *FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET* ，那么下次再从home中进入到task中，那么 *将删除设置了该属性的activity以上所有的activity* ，例如A-->B-->C ==> D-->E,加入在C启动D时设置了该属性，那么下次从HOME中再次进入到这个task中时，将会是A-->B-->C。
  - 七⑦ 如果 *复用task中的activity的resultTo不为空* ，也就是启动这个activity的是一个activity，那么 *这个activity的处理将按照它的前一个activity的处理方式来处理* ，不管 *在何时情况下，它的前一个activity都是启动它的activity* ，(即便resultTo不是前一个activity，如设置了Intent. *FLAG_ACTIVITY_FORWARD_RESULT*) 。如果复用task中每个activity的resultTo都不为空，并且上述处理优先级在其前面的属性没有设置的话，那么 *这个复用task中的activity将不作任何的处理(这种情况没有看懂，不知道这种情况为什么可以不用处理？？？)* 。
- 一般情况下，activity的resultTo都不为空，除非设置了Intent. *FLAG_ACTIVITY_FORWARD_RESULT* ，那么此时被启动的activity的caller的resultTo将会为空。
- task中的activity的属性设置是上述属性的组合，因此 *reset task过程要按照一定的优先级来处理* ，上述属性的处理优先级是： *六⑥ = 四④ > 七⑦ > 五⑤ > 三③ = 二② > 一①*
          - 具体操作顺序如下：
  - ♣ 根据六⑥，四④条件来 *删除复用task中相应的activity；*
  - ♣ 七⑦条件下，将会 *暂时不做处理，再根据它的前一个activity的属性来做处理，即使这个activity设置了allowTaskReparenting；*
  - ♣ *如果activity的resultTo为空，并且满足条件五⑤* ，那么 *将其及其以上未作处理的，满足条件七⑦的所有activity，一并进行TaskReparenting操作，并放置在mHistory栈底。它们在mHistory栈底顺序如同在复用task中的顺序；*
  ♣ *根据一①二②三③的条件来删除复用task中相应的activity。*
***** ⑵ mHistory中，不属于复用task的activity，并且它的resultTo不为空，那么将根据它的前一个activity的处理来处理；
***** ⑶ mHistory中，不属于复用task，但是和当前启动的activity有相同affinity，并且允许TaskReparenting操作，那么将进行以下操作：
      - ♣ 如果满足上述的①②③④的条件，但是其中的task不是复用task，而是这个activity所处的task，那么将输出这个activity，而不是进行TaskReparenting操作。
  - 为什么非复用task中的activity，和当前启动的activity有相同affinity，并且允许TaskReparenting操作，满足了①②③④的条件之后要删除呢，为什么非复用task中的其他activity，不需要删除呢？
  - *正因为它和启动的activity有相同的affinity，因此AMS认为这个activity是和启动activity相关的，以后可能会重新调用，所以当其满足删除条件后,这时它将不允许TaskReparenting操作，并且不应该再允许它存在于其他的task中，此时应该删除。*
- ♣ 如果没有满足①②③④的条件，那么将会对其进行TaskReparenting操作，重新将其移动到复用task或新启动的task中。
      #+BEGIN_SRC csharp
          // If the caller has requested that the target task be  
          // reset, then do so.  
          if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {  
              taskTop = resetTaskIfNeededLocked(taskTop, r);  
          }  
                #+END_SRC 
- 上面就是这个复用task的reset 过程，它的执行过程是按照上述的⑴⑵⑶的顺序来执行的，下面给出一个图示，便于更好的理解reset task的过程。
  
[[./pic/activityService_20220829_104430.png]]
*** 5.5 判断是否有可复用的activity
- 如果mHistory中有可复用的task，那么在某些情况下并不需要启动这个activity，下面分析具体是什么情况：
- ⑴ Intent设置了Intent.FLAG_ACTIVITY_CLEAR_TOP，或者launchMode == ActivityInfo.LAUNCH_SINGLE_TASK，或者r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE；这3种条件有一个共同点，就是启动的activity启动之后，在这个task中,这个activity之上不能有其他的activity。
  - 一般情况下，需要将复用task中启动的activity之上的所有的activity删除，
  - 当activity的launchMode == ActivityInfo. *LAUNCH_MULTIPLE，即普通模式* ，并且 *Intent并未要求singletop模式* ，这种情况是 *连复用task中与启动activity相同的activity都要删除，也就是不希望复用相同的activity。*
  - *performClearTaskLocked()* 实现了上述功能，并返回可复用的activity。
#+BEGIN_SRC csharp
ActivityRecord top = performClearTaskLocked(  
    taskTop.task.taskId, r, launchFlags, true);  
#+END_SRC 
  - 如果有可复用的activity，并且这个activity是task的root activity，由于task的Intent是root activity的Intent，所以需要重新设置task的Intent。
  - 向可复用的activity发送新的Intent，通知它Intent的变化，最终会调用到这个activity的onNewIntent()方法。
- ⑵ 如果不满足⑴条件的话，但是启动的activity与复用task的root activity相同。
  - 如果此时Intent设置了Intent.FLAG_ACTIVITY_SINGLE_TOP，并且复用task的top activity正好是要启动的activity，则复用这个activity，同时更新activity的Intent，如果需要更新task的Intent。
  - 如果Intent没有设置了Intent.FLAG_ACTIVITY_SINGLE_TOP，即使设置了，但是当前的top activity不是正要启动的activity，那么会判断当前启动的Intent和task的Intent不同，那么将会重新启动这个activity。
  - 其他情况，将直接resume top的activity。
- ⑶ 如果⑴ ⑵条件均不满足，其实如果不满足⑴ ⑵条件的话，复用的task中就不存在与启动的activity相同的activity了，如果启动的Intent没有设置Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么一定不会复用任何的activity。
- (4) 如果⑴ ⑵条件均不满足，并且Intent设置了Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么需要检查当前复用task的Intent是否设置了Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。
- 如果没有设置，重新设置新的Intent,同样不可能复用activity。
- 这种情况下，将不会显示要启动的activity，而是改为显示复用的task中的内容，如下图：
  
[[./pic/activityService_20220829_104857.png]]
- 至此，整个Task复用，已经activity复用的过程就介绍完了，如果没有可复用的activity，则需要启动一个新的activity，如果有可复用的activity，那么activity的启动过程至此结束，直接调用resumeTopActivityLocked()resume top的activity即可。
- *以后的处理均为Task复用和activity复用失败之后的处理。*
** 6 singleTop和singleTask属性的处理
   - 这一部分是针对singleTop和singleTask属性的处理，前面分析Task复用的时候，也有对singleTop和singleTask属性的处理，两者有什么不同呢？
- Task复用中是启动的activity需要在新的task中，而这里的处理主要是针对同一个task。
- 当设置Intent.FLAG_ACTIVITY_SINGLE_TOP或者launchMode == ActivityInfo.LAUNCH_SINGLE_TOP或者launchMode == ActivityInfo.LAUNCH_SINGLE_TASK这几种情况下，如果top activity与启动的activity为同一个activity，那么将复用top activity，并直接resume top activity。
#+BEGIN_SRC csharp
if (top != null && r.resultTo == null) {  
    if (top.realActivity.equals(r.realActivity)) {  
        if (top.app != null && top.app.thread != null) {  
            if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0  
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP  
                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {  
                logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);  
// For paranoia, make sure we have correctly  
// resumed the top activity.  
                if (doResume) {  
                    resumeTopActivityLocked(null);  
                }  
                if (onlyIfNeeded) {  
                    // We don't need to start a new activity, and  
                    // the client said not to do anything if that  
                    // is the case, so this is it!  
                    return START_RETURN_INTENT_TO_CALLER;  
                }  
                top.deliverNewIntentLocked(callingUid, r.intent);  
                return START_DELIVERED_TO_TOP;  
            }  
        }  
    }  
}  
#+END_SRC 
- r.resultTo == null这个条件是在startActivityForResult()的requestCode<0时成立。
- 为什么没有ActivityInfo. *LAUNCH_SINGLE_INSTANCE* ？这是 *因为这种启动模式，如果Task复用失败之后，直接启动为其启动一个Intent.FLAG_ACTIVITY_NEW_TASK即可。*
** 7 standard和singleInstance模式
   - 为什么代码中没有明显的针对ActivityInfo.LAUNCH_SINGLE_INSTANCE模式的处理？这是因为这种启动模式，如果Task复用失败之后，直接启动为其启动一个Intent.FLAG_ACTIVITY_NEW_TASK即可。
- ⑴ 设置了Intent.FLAG_ACTIVITY_NEW_TASK，则为该activity创建一个新的task；
- ⑵ 在当前的task中启动新的activity，
  - 一①当前的caller是一个activity，如果设置Intent.FLAG_ACTIVITY_CLEAR_TOP，当前的task如果存在要启动的activity(这个和上一节中的Task复用时的clear top过程不同，两者是互斥的过程，不冲突)，清除其上的所有的activity；
  - 二② 当前的caller是一个activity，如果设置Intent.FLAG_ACTIVITY_REORDER_TO_FRONT，这个flag表示如果启动的activity已经在当前的task中，那么如果当前启动的Intent设置了该flag，那么则会将这个activity从task中移动到top。
    - 如果A-->B-->C-->D，D启动B时，设置了该flag，那么将变为A-->C-->D-->B
    - ①②两个条件，则不需要再启动新的activity，直接resume top。
  - 三③  当前的caller是一个activity，其他情况则需要启动新的activity。
- ⑶ 当前的caller不是activity，那么仍将新启动的activity放在top的task中。

* AMS在Android起到什么作用？简单的分析下Android的源码
- https://cloud.tencent.com/developer/article/1466430
- 概述
- 相信大多数动脑同学对文章中提到的ActivityManagerService（以后简称AMS）都有所耳闻。
- *AMS是Android中最核心的服务* ，主要负责 *系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要* 。 AMS是碰到的第一块难啃的骨头[①]，涉及的知识点较多。为了帮助读者更好地理解AMS，接下来将带小伙伴么按五条不同的线来分析它。
  - *第一条线* ：同其他服务一样，将分析SystemServer中AMS的调用轨迹。
  - *第二条线* ：以am命令启动一个Activity为例，分析应用进程的创建、Activity的启动，以及它们和AMS之间的交互等知识。
  - *第三条线和第四条线* ：分别以Broadcast和Service为例，分析AMS中Broadcast和Service的相关处理流程。
  - *第五条线* ：以一个Crash的应用进程为出发点，分析AMS如何打理该应用进程的身后事。 除了这五条线外，还将统一分析在这五条线中频繁出现的与AMS中应用进程的调度、内存管理等相关的知识。 提示ContentProvider将放到下一章分析，不过本章将涉及和ContentProvider有关的知识点。 先来看AMS的家族图谱:
    
[[./pic/activityService_20220829_153056.png]]
- 由图可知：
  - AMS由ActivityManagerNative（以后简称AMN）类派生，并实现Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口。而AMN由Binder派生，实现了IActivityManager接口。
  - 客户端使用ActivityManager类。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。
  - AMS由SystemServer的ServerThread线程创建;
** 1. 初识ActivityManagerService总结
- 本节所分析的4个关键函数均较复杂，与之相关的知识点总结如下：
  - AMS的main函数：创建AMS实例，其中最重要的工作是创建Android运行环境，得到一个ActivityThread和一个Context对象。
  - AMS的setSystemProcess函数：该函数注册AMS和meminfo等服务到ServiceManager中。另外，它为SystemServer创建了一个ProcessRecord对象。由于AMS是Java世界的进程管理及调度中心，要做到对Java进程一视同仁，尽管SystemServer贵为系统进程，此时也不得不将其并入AMS的管理范围内。
  - AMS的installSystemProviders：为SystemServer加载SettingsProvider。
  - AMS的systemReady：做系统启动完毕前最后一些扫尾工作。该函数调用完毕后，HomeActivity将呈现在用户面前。 对AMS 调用轨迹分析是我们破解AMS的第一条线，希望读者反复阅读，以真正理解其中涉及的知识点，尤其是和Android运行环境及Context相关的知识。
** 2. startActivity
- *总结* 本文详细startActivity的整个启动流程，
    - 流程[2.1 ~2.4]:运行在调用者所在进程，比如从桌面启动Activity，则调用者所在进程为launcher进程，launcher进程利用ActivityManagerProxy作为Binder Client，进入system_server进程(AMS相应的Server端)。
    - 流程[2.5 ~2.18]:运行在system_server系统进程，整个过程最为复杂、核心的过程，下面其中部分步骤：
    - 流程[2.7]：会调用到resolveActivity()，借助PackageManager来查询系统中所有符合要求的Activity，当存在多个满足条件的Activity则会弹框让用户来选择;
    - 流程[2.8]：创建ActivityRecord对象，并检查是否运行App切换，然后再处理mPendingActivityLaunches中的activity;
    - 流程[2.9]：为Activity找到或创建新的Task对象，设置flags信息；
    - 流程[2.13]：当没有处于非finishing状态的Activity，则直接回到桌面； 否则，当mResumedActivity不为空则执行startPausingLocked()暂停该activity;然后再进入startSpecificActivityLocked()环节;
    - 流程[2.14]：当目标进程已存在则直接进入流程[2.17]，当进程不存在则创建进程，经过层层调用还是会进入流程[2.17];
    - 流程[2.17]：system_server进程利用的ATP(Binder Client)，经过Binder，程序接下来进入目标进程。
    - 流程[2.19 ~2.18]:运行在目标进程，通过Handler消息机制，该进程中的Binder线程向主线程发送H.LAUNCH_ACTIVITY，最终会通过反射创建目标Activity，然后进入onCreate()生命周期。 从另一个角度下图来概括：
      
[[./pic/activityService_20220829_153243.png]]
- *启动流程：*
  - 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；
  - system_server进程接收到请求后，向zygote进程发送创建进程的请求；
  - Zygote进程fork出新的子进程，即App进程；
  - App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；
  - system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；
  - App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；
  - 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。
** startActivity后半程总结
   
[[./pic/activityService_20220829_153328.png]]
- *starActivity总结*
- Activity的启动就介绍到这里。这一路分析下来，相信读者也和笔者一样觉得此行绝不轻松。先回顾一下此次旅程：
  - 行程的起点是am。am是Android中很重要的程序，读者务必要掌握它的用法。我们利用am start命令，发起本次目标Activity的启动请求。
  - 接下来进入ActivityManagerService和ActivityStack这两个核心类。对于启动Activity来说，这段行程又可分细分为两个阶段：第一阶段的主要工作就是根据启动模式和启动标志找到或创建ActivityRecord及对应的TaskRecord；第二阶段工作就是处理Activity启动或切换相关的工作。
  - 首先讨论了AMS直接创建目标进程并运行Activity的流程，其中涉及目标进程的创建，在目标进程中Android运行环境的初始化，目标Activity的创建以及触发onCreate、onStart及onResume等其生命周期中重要函数调用等相关知识点。
  - 接着又讨论了AMS先pause当前Activity，然后再创建目标进程并运行Activity的流程。其中牵扯到两个应用进程和AMS的交互，其难度之大可见一斑。 读者在阅读本节时，务必要区分此旅程中两个阶段工作的重点：其一是找到合适的ActivityRecord和TaskRecord；其二是调度相关进程进行Activity切换。在SDK文档中，介绍最为详细的是第一阶段中系统的处理策略，例如启动模式、启动标志的作用等。第二阶段工作其实是与Android组件调度相关的工作。SDK文档只是针对单个Activity进行生命周期方面的介绍。 坦诚地说，这次旅程略过不少逻辑情况。原因有二，一方面受限于精力和篇幅，另方面是作为调度核心类，和AMS相关的代码及处理逻辑非常复杂，而且其间还夹杂了与WMS的交互逻辑，使复杂度更甚。再者，笔者个人感觉这部分代码绝谈不上高效、严谨和美观，甚至有些丑陋（在分析它们的过程中，远没有研究Audio、Surface时那种畅快淋漓的感觉）。 此处列出几个供读者深入研究的点：
  - 各种启动模式、启动标志的处理流程。
  - Configuration发生变化时Activity的处理，以及在Activity中对状态保存及恢复的处理流程。
  - Activity生命周期各个阶段的转换及相关处理。Android 2.3以后新增的与Fragment的生命周期相关的转换及处理。
** 3. 广播处理总结
   
[[./pic/activityService_20220829_153416.png]]
** 4. startService流程图
*总结* 5.1 流程说明 在整个startService过程，从进程角度看服务启动过程
  - *Process A进程* ：是指调用startService命令所在的进程，也就是启动服务的发起端进程，比如点击桌面App图标，此处Process A便是Launcher所在进程。
  - *system_server进程* ：系统进程，是java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的，每个进程binder线程个数的上限为16。
  - *Zygote进程* ：是由init进程孵化而来的，用于创建Java层进程的母体，所有的Java层进程都是由Zygote进程孵化而来；
  - *Remote Service进程* ：远程服务所在进程，是由Zygote进程孵化而来的用于运行Remote服务的进程。主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），当然还有其他线程，这里不是重点就不提了。
    
[[./pic/activityService_20220829_153526.png]]
- 图中涉及3种IPC通信方式：Binder、Socket以及Handler，在图中分别用3种不同的颜色来代表这3种通信方式。一般来说，同一进程内的线程间通信采用的是 Handler消息队列机制，不同进程间的通信采用的是binder机制，另外与Zygote进程通信采用的Socket。
- *启动流程：*
  - Process A进程采用Binder IPC向system_server进程发起startService请求；
  - system_server进程接收到请求后，向zygote进程发送创建进程的请求；
  - zygote进程fork出新的子进程Remote Service进程；
  - Remote Service进程，通过Binder IPC向sytem_server进程发起attachApplication请求；
  - system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向remote Service进程发送scheduleCreateService请求；
  - Remote Service进程的binder线程在收到请求后，通过handler向主线程发送CREATE_SERVICE消息；
  - 主线程在收到Message后，通过发射机制创建目标Service，并回调Service.onCreate()方法。 到此，服务便正式启动完成。当创建的是本地服务或者服务所属进程已创建时，则无需经过上述步骤2、3，直接创建服务即可。
** 5. AMS中的进程管理
- 前面曾反复提到，Android平台中很少能接触到进程的概念，取而代之的是有明确定义的四大组件。但是作为运行在Linux用户空间内的一个系统或框架，Android不仅不能脱离进程，反而要大力利用Linux OS提供的进程管理机制和手段，更好地为自己服务。作为Android平台中组件运行管理的核心服务，ActivityManagerService当仁不让地接手了这方面的工作。目前，AMS对进程的管理仅涉及两个方面：
  - 调节进程的调度优先级和调度策略。
  - 调节进程的OOM值。
** 6. App的Crash处理总结
- 应用进程进行Crash处理的流程。[[图片上传失败...(image-bd3406-1561648443575)]
*** 一、概述
- ActivityManagerService是Framework层的核心服务之一，ActivityManagerService是Binder的子类,它的功能主要以下三点：
  - 四大组件的统一调度
  - 进程管理
  - 内存管理
*** 二、ActivityManagerService的启动过程
- ActivityManagerService的启动是在systemserver进程的startBootstrapServices方法中启动的。
- SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要： 创建ActivityManagerService.Lifecycle对象； 调用Lifecycle.onStart()方法。
*** 三、主要功能之一的四大组件的统一调度
- *ActivityManagerService最主要的功能就是统一的管理者activity，service,broadcast,provider的创建,运行,关闭.* 我们在应用程序中启动acitivity,关闭acitiviy等操作最终都是要通过ams来统一管理的.这个过程非常的复杂，不是一下子可以讲的清楚的，我这里推荐老罗的博客来讲解四大组件的启动过程：
- Android应用程序内部启动Activity过程（startActivity）的源代码分析 Android系统在新进程中启动自定义服务过程（startService）的原理分析 Android应用程序注册广播接收器（registerReceiver）的过程分析 Android应用程序发送广播（sendBroadcast）的过程分析 Android应用程序组件Content Provider简要介绍和学习计划
*** 四、主要功能之一的内存管理
- 我们知道当一个进程中的acitiviy全部都关闭以后,这个空进程并不会立即就被杀死，而是要等到系统内存不够时才会杀死。但是实际上ActivityManagerService并不能够管理内存，android的内存管理是Linux内核中的内存管理模块和OOM进程一起管理的。
- Android进程在运行的时候,会通过Ams把每一个应用程序的oom_adj值告诉OOM进程,这个值的范围在-16-15,值越低说明越重要，越不会被杀死。当发生内存低的时候,Linux内核内存管理模块会通知OOm进程根据AMs提供的优先级强制退出值较高的进程。因此Ams在内存管理中只是扮演着一个提供进程oom_adj值的功能.真正的内存管理还是要调用OOM进程来完成，下面通过调用Activity的finish()方法来看看内存释放的情况。
- 当我们手动调用finish()方法或者按back键时都是会关闭activity的，在调用finish的时候只是会先调用ams的finishActivityLocked方法将当前要关闭的acitiviy的finish状态设置为true，然后就会先去启动新的acitiviy，当新的acitiviy启动完成以后就会通过消息机制通知Ams，Ams在调用activityIdleInternalLocked方法来关闭之前的acitiviy。

* ActivityManager的实现: IActiivtyManager接口类的前世今生，与aidl鸡生蛋与蛋生鸡的问题
** 通过Parcelable实现的Intent
- 首先我们可以来看看Intent与Activity的内部实现机制。作为Android应用层最强大最灵活的跨进程通信方式，Intent本质上就是一个Parcelable类，是通过Parcelable接口创建的，可在多个进程之间进行传输的消息：
  
[[./pic/activityService_20220831_073202.png]]
- Intent实现了Parcelable接口，在传输一个Intent对象时，我们便可以使用Parcelable协议，但Intent里包含的信息写入到一个Parcel对象的buffer里，然后再传递给另一个进程处理。在Intent处理里，大部分信息都是使用的基本数据类型，比如mAction、mType、mPackage、mComponent都是String。对于比较特殊的Uri类型的mData，因为Uri这种类型的类也是复杂构造的类，于是Uri也被会实现Parcelable接口。而另一个复杂类型mExtras，因为我们在现实中可能通过mExtras传递任意复杂的数据对象，于是mExtras是一个继承自Bundle类的字典型数据结构。于是，我们得到的Intent的构成便是一个简单的Parcelable实现：
  
[[./pic/activityService_20220831_073216.png]]
- Intent的源代码位于frameworks/base/core/java/android/content/Intent.java。我们会看到这一代码实现的Parcelable比我们范例里的要复杂。这跟实际情况相符，我们现实中使用的aidl接口实现与Parcelable接口实现，都会比我们例子里的要复杂，因为Parcelable接口与aidl接口只是解决跨进程传输问题，相当于是提供给跨进程访问的Public属性或方法，但我们每个对象除了有Public属性，还会有Private属性，只在当前进程内有效的，为当前对象提供一些辅助属性与操作方法，所以除了aidl与Parcelable，这些基于IBinder的对象还会有其他部分的实现。
** Intent的发送 --- IActiivtyManager接口类
- 在创建了Intent之后，大体上会有三种Intent的发送方式，startActivity()|startActivityForResult()来启动一个Activity，startService()|bindService()来启动一个Service，以及sendBroadcast()来发送广播消息。而在Android内部实现上，Intent的发送，大致都如下图所示：
  
[[./pic/activityService_20220831_073247.png]]
- Intent的发送，分别有可能通过Context的startActivity()、startService()、sendBroadcast()三个出口进行发送。Context由Framework实现的ContextImpl来提供具体的发送功能，在ContextImpl类里会经过不同的特殊处理，比如在startActivity()之上会再套接一层execStartActivity()方法来驱动Instrumentation测试框架，但最终都会通过ActivityManagerNative类来访问到一个处理Intent请求的gDefault对象。正如我们看到的gDefault，实际上是Singleton<IActivityManager>生成的进程唯一的IActivityManager对象。于是，最终，所有的Intent，都会通过IActivityManager来走入Activity、Service与Broadcast三个不同的处理方法。
- 如果是按照aidl的标准写法，此时我们理论上应该会在IAcitvityManager.java的同一级目录里找到一个IActivityManager.aidl文件。但很不幸，我们找不到这么一个文件，跟我们前面见到的aidl实现似乎很不一样。所有需要使用到AIDL实现的地方，总需要某种机制可以得到IBinder引用，而像ActivityManager，还有稍后会介绍的一个ServiceManager，都会是尝试去获取一个IBinder引用的，这时便有了个“鸡与蛋”的问题，为了简化逻辑，于是这一层便是绕开AIDL，直接实现IActivityManager接口类。
- 仔细看一下的话，其实IActivityManager.java与通过aidl自动生成的文件很类似，基本构成都是一样：
#+BEGIN_SRC csharp
public interface IActivityManagerextends IInterface { // <<<<<<<<<< 1

    public int startActivity(IApplicationThread caller,
                             Intent intent, String resolvedType, Uri[] grantedUriPermissions,
                             int grantedMode, IBinder resultTo, String resultWho,int requestCode,
                             boolean onlyIfNeeded, boolean debug) throws RemoteException; // <<<<<<<<<< 2
    public boolean finishActivity(IBinder token,int code, Intent data) throws RemoteException;          
    public int broadcastIntent(IApplicationThread caller, Intent intent,
                               String resolvedType, IIntentReceiver resultTo, int resultCode,
                               String resultData, Bundle map, String requiredPermission,
                               boolean serialized, boolean sticky) throws RemoteException;
    public ComponentName startService(IApplicationThread caller, Intent service,
                                      String resolvedType) throws RemoteException;
    public int bindService(IApplicationThread caller, IBinder token,
                           Intent service, String resolvedType,
                           IServiceConnection connection, int flags)throws RemoteException;

    String descriptor = "android.app.IActivityManager"; // <<<<<<<<<< 3

    int START_RUNNING_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;
    int HANDLE_APPLICATION_ERROR_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+1;
    int START_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2;
    int UNHANDLED_BACK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3;
    int OPEN_CONTENT_URI_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; // <<<<<<<<<< 4
}
#+END_SRC 
- 与根据aidl定义生成的接口类一样，IActivityManager也是基于IInterface生成的接口类，于是在这里我们只会定义接口方法，而不提供具体实现。
- 对于每一个需要实现接口方法而言，因为每个方法都将是跨进程的调用，所以每个方法都必须抛出Remote Exception。
- 作为使用Binder传输对象，都需要一个DESCRIPTOR作为传输时的标识，于是在Binder接收时会以这个Token作为验证传输是否有效的凭据。
- 虽然不是自动生成，但在这一接口类也会定义一系列Binder命令，Binder命令都是从IBinder.FIRST_CALL_TRANSACTION开始，其他命令都会通过+1进行Binder命令的统一化。
** IActiivtyManager的Proxy端实现
- 但是，由于IActivityManager.java不是由aidl工具自动生成的，于是不会自生成的Stub和Proxy对象，这些对象都须由实现这一接口类的部分实现，提供发送与接收两端的Binder处理的接口方法。我们可以在源代码里行搜索，发现 *实现IActivityManager接口类的居然又回到ActivityManagerNative.java，是由这一文件里的ActivityManagerProxy类来实现Proxy端功能* 。这是Android的一个缺陷，有时代码会不必要地“回溯”。所以从代码角度分析，最后我们 *得到的会是Remote Service的Proxy端代码：*
#+BEGIN_SRC csharp
package android.app; // <<<<<<<<<< 1 代码是属于我们Android应用程序的进程空间内，可直接使用的对象
import android.content.ComponentName;

// 这个类具备了Binder通信能力: 
public abstract class ActivityManagerNative extends Binder implements IActivityManager { // <<<<<<<<<< 2

    // 检测ActivityManager对应的Service端是否已经就绪，并在就绪的情况下创建ActivityManagerProxy对象
    static public IActivityManager asInterface(IBinder obj) { // <<<<<<<<<< 3
        if (obj == null) 
            return null;
        IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
        if (in != null) 
            return in;
        return new ActivityManagerProxy(obj); // <<<<<<<<<< 4 只可能在客户端调用到
    }

    // 解决IActivityManager与aidl的鸡与蛋问题的办法
    static public IActivityManager getDefault() { // <<<<<<<<<< 5 
        if (gDefault != null) 
            return gDefault;
        IBinder b = ServiceManager.getService("activity");    
        gDefault = asInterface(b); // <<<<<<<<<< 6
        return gDefault;
    }

// 通过ActivityManager的testIsSystemReady远程调用来检测系统是否已经就绪
    static boolean sSystemReady =false;
    static public boolean isSystemReady() { // <<<<<<<<<< 7
        if (!sSystemReady) 
            sSystemReady = getDefault().testIsSystemReady();
        return sSystemReady;
    }

    public ActivityManagerNative() { // 将descriptor通过attachInterface()写入Binder通信里
        attachInterface(this, descriptor); // <<<<<<<<<< 8 将descriptor通过attachInterface()写入Binder通信里
    }
    public boolean onTransact(int code, Parcel data,Parcel reply,int flags)
        throws RemoteException { // <<<<<<<<<< 9
        switch (code) {
        // ActivityManagerService所需要实现的就只剩下这里缺失的具体实现了
        case START_ACTIVITY_TRANSACTION: // <<<<<<<<<< 10 解析完成后具体执行的方法
            // ...
        case START_ACTIVITY_AND_WAIT_TRANSACTION:
            // ...
        case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
            // ...
        case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
            // ...  
        case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
            // ...
        case FINISH_ACTIVITY_TRANSACTION:
            // ...
            // 在解析完所有在IActivityManager接口里定义的Binder命令之后，
            // 会通过IoC(Inversion of Controll)模式，反向调用到Binder的onTransact()处理通用Binder命令。
            return super.onTransact(code, data, reply, flags); // <<<<<<<<<< 11
        }
        public IBinder asBinder() { // <<<<<<<<<< 12 Service端的asBinder实现，返回一个IBinder引用
            // IInterface接口实际只需要这一接口方法，这一接口方法的神奇之处在于，
              // 在客户端调用里，asBinder()会返回针对Proxy端的IBinder引用，
              // 在Service实现部分，则会返回Stub对象的IBinder引用。
            return this;
        }
        private static IActivityManager gDefault;
    }

    class ActivityManagerProxy implements IActivityManager { // <<<<<<<<<< 13
        public ActivityManagerProxy(IBinder remote) {
            mRemote = remote;
        }
        public IBinder asBinder() { // <<<<<<<<<< 14 Proxy端提供的asBinder()，会返回Proxy的IBinder引用
            return mRemote;    
        }
        // 作为Proxy对象，ActivityManagerProxy类里也必须提供IActivityManager接口里所有方法的实现
        public int startActivity(IApplicationThread caller, Intent intent,
                                 String resolvedType, Uri[] grantedUriPermissions, int grantedMode,
                                 IBinder resultTo, String resultWho,
                                 int requestCode, boolean onlyIfNeeded,
                                 boolean debug) throws RemoteException { // <<<<<<<<<< 15
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            data.writeInterfaceToken(IActivityManager.descriptor);
            data.writeStrongBinder(caller != null ? caller.asBinder() :null);
            intent.writeToParcel(data, 0);
            data.writeString(resolvedType);
            data.writeTypedArray(grantedUriPermissions, 0);
            data.writeInt(grantedMode);
            data.writeStrongBinder(resultTo);
            data.writeString(resultWho);
            data.writeInt(requestCode);
            data.writeInt(onlyIfNeeded ? 1 : 0);
            data.writeInt(debug ? 1 : 0);
            mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
            reply.readException();
            int result = reply.readInt();
            reply.recycle();
            data.recycle();
            return result;
        }
        public int broadcastIntent(IApplicationThread caller,
                                   Intent intent, String resolvedType, IIntentReceiver resultTo,
                                   int resultCode, String resultData, Bundle map,
                                   String requiredPermission, boolean serialized,
                                   boolean sticky) throws RemoteException           {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            data.writeInterfaceToken(IActivityManager.descriptor);
            data.writeStrongBinder(caller != null ? caller.asBinder() :null);
            intent.writeToParcel(data, 0);
            data.writeString(resolvedType);
            data.writeStrongBinder(resultTo != null ? resultTo.asBinder() :null);
            data.writeInt(resultCode);
            data.writeString(resultData);
            data.writeBundle(map);
            data.writeString(requiredPermission);
            data.writeInt(serialized ? 1 : 0);
            data.writeInt(sticky ? 1 : 0);
            mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0);
            reply.readException();
            int res = reply.readInt();
            reply.recycle();
            data.recycle();
            return res;
        }
        private IBinder mRemote;
    }
}
#+END_SRC 
- 从包名也可以看出，这部分代码是属于我们Android应用程序的进程空间内，可直接使用的对象，Intent会由应用程序通过ActivityManagerNative，将方法对应的Binder命令发送出去。
- 这里通过一个ActivityManagerNative类来实现了IActivityManager接口，同时也会继承自Binder，于是 *这个类具备了Binder通信能力* 。但我们注意到这个类是一个抽象类，于是它对于接口方法会不会提供实现是没有保证的。而我们可以注意到是， *ActivityManagerNative这个对象被创建之后，是会提供给应用程序来使用的，于是最终这个类可能也只会需要Proxy端的功能* 。
- 正如我们在 *aidl编程* 里看到过， *asInterface()是提供给Proxy端来创建一个Proxy 对象的接口方法* 。于是在这一方法的实现里，会 *先通过queryLocalInterface()查询一下Binder通信里是否存在以descriptor为标识的监听端，存在则说明已经有IActivityManager的Service端，然后就创建一个ActivityManagerProxy对象，准备后续的命令发送* 。但与aidl不同之处在于， *aidl可以通过bindService()来启动一个Service并与之建立binder通信，然后就可以在onServiceConnected()里取回这个Service的IBinder引用* 。但 *这种操作对于ActivityManager来说是不现实的，因为基于Intent通信的bindService()，本身也就是通过ActivityManager来发送的（鸡和蛋的问题）* 。于是，我们 *并不能直接通过aidl来完成IActivityManager实现，因为没法使用bindService()，这是IActivityManager接口与标准AIDL的唯一区别，IActivityManager是aidl机制的基础* 。
- 这部分只可能在客户端调用到，于是当前面的检测条件都已通过之后，就会直接返回一个ActivityManagerProxy对象。
- getDefault()，则是解决IActivityManager与aidl的鸡与蛋问题的办法。因为没法使用标准的bindService()，然后再通过IBinder.Stub.asInterface()取回Remote Service引用，所以Intent的发送便使用了比较特殊的方式，会先直接调用ActivityManagerNative对象的getDefault()，正如我们前面的执行流程里分析的那样。而在这个getDefault()方法里，会通过SystemManager.getService()取回来一个叫activity的service。这部分代码在Android 3.0之后，出于兼容Fragment的考虑，开始使用Singleton模式运行ActivityManagerProxy，于是会有我们图中的Singleton<ActivityManagerProxy>。
- 通过asInterface()来检测ActivityManager对应的Service端是否已经就绪，并在就绪的情况下创建ActivityManagerProxy对象。从getDefault()成功之后，Intent则可以通过这个Proxy对象来与系统进程里执行ActivityManagerService来进行通信了。
- isSystemReady()，通过ActivityManager的testIsSystemReady远程调用来检测系统是否已经就绪。
- ActivityManagerNative的初始化方法，在这一方法里会将descriptor通过attachInterface()写入Binder通信里。虽然ActivityManagerNative类只是一个抽象类，但提供了这些通用方法，就可以让真正实现IActivityManager接口的ActivityManagerService代码尽可能只专注于Service端代码实现，也通过定义Proxy端与Service端的共用属性，像descriptor、IBinder命令等，来达到代码尽可能被重用的目的。
- 从我们前面aidl实现部分可以看到，实际上onTransact()是完成IBinder命令的解析与转发功能的代码。在抽象类里提供onTransact()，则可以重用IBinder命令的定义。因为这里执行的都会是远程调用，所以也必须抛出Remote Service。
- 通过onTransact()方法解析完成后具体执行的方法，在这里则不会提供实现。对于每一个不同的Binder命令，它都会从Binder里取出参数，然后再调用相应的方法实现（虽然现在还不存在），然后再把执行结果和异常信息写回Binder。于是ActivityManagerService所需要实现的就只剩下这里缺失的具体实现了。
- 出于处理Binder通用性命令的需求，在解析完所有在IActivityManager接口里定义的Binder命令之后，会通过IoC模式，反向调用到Binder的onTransact()处理通用Binder命令。
- Service端的asBinder实现，返回一个IBinder引用。我们的IInterface接口实际只需要这一接口方法，这一接口方法的神奇之处在于，在客户端调用里，asBinder()会返回针对Proxy端的IBinder引用，在Service实现部分，则会返回Stub对象的IBinder引用。到此为止，实际上ActivityManagerNative就已经把Binder接收部分的代码实现了，对于具体的IActivityManager接口的Service端实现，所剩的工作，也就只有具体的远程方法的实现。
- 因为我们在客户端部分使用IActivityManager接口，已经可以通过ActivityManagerNative类的getDefault()方法来创建Proxy对象来完成，于是IActivityManager接口的Proxy实现，便与普通的aidl实现没有任何区别了。我们的ActivtityManagerProxy，也就会是一个实现IActivityManager接口的类，可以基于这个类来创建Proxy对象。
- 对于同一IInterface，Proxy端提供的asBinder()，会返回Proxy的IBinder引用。
- 作为Proxy对象，ActivityManagerProxy类里也必须提供IActivityManager接口里所有方法的实现。不过，这里并不会有真正的调用实现，而只是将参数通过Parcel进行序列化操作，再把需要执行的Binder命令与写入Parcel的参数，通过Binder发送出去。然后执行将会被Binder阻塞，直接远程调用返回。在继续执行时，这时就取出执行结果与异常信息，返回给调用这一方法的地方。所有的命令在发送时都会使用IActivityManager.descriptor作为传输时的凭据，所以也会保证这些命令会被正确地发送到IActivityManager的Service实现。因为是访问远程方法调用，于是会同样将在Binder里读到的Remote Exception上抛，以被合适的代码捕捉处理。
- 所以，从代码层面来看，除了因为bindService()传输上的“鸡与蛋”问题，我们的ActivityManager本身与普通的aidl编程没有本质区别，只是通过一层getDefault()方法来绕开bindService()的使用。但是因为IActivityManager接口本身需要支持bindService()机制，所以对实现IActivityManager的Service端的代码来说，就没有Service的生存周期这回事了。
- 基于这样分析，最后，我们上面Proxy端的执行逻辑，实际上在内部实现是这样进行交互的：
  
[[./pic/activityService_20220831_080158.png]]
- 通过ActivityManagerNative的getDefault()方法，我们最终得到的gDefault会是一个ActivityManagerProxy对象，然后我们所有的调用，会通过ActivityManagerProxy里对于各个方法的封装，再将具体的命令通过Binder发送到IActivityManager的Service实现部分。
- 于是对于IActivityManager这一接口类，剩下的工作便是看看它是如何被响应处理的。
** IActiivtyManager的Stub端实现
- 对于IActivityManager的Service的实现部分，因为整个Stub接口都已经在抽象类ActivityManagerNative里完成了，所以也跟aidl会有不一样之处，我们不需要创建一个Stub对象，然后再在这个Stub对象里提供具体的方法实现，而是只需要根据onTransact()解析出来的方法提供具体实现。一般的Remote Service，Stub对象是通过onBind()回调方法触发创建的，会返回一个IBinder的引用到客户端。对于IActivityManager来说没有这样的触发点，它反倒是会远程调用到这一回调方法，所以这里并不需要实现这部分代码，而是保持循环，提供这种onBind()触发能力。
- IActivityManager的Stub端，是会运行在SystemServer进程空间里，由frameworks/base/services/java/com/android/server/am/ActivityManagerService.java实现的。从前面的代码可以看出，其实ActivityManagerNative类已经将Binder接收端的代码封装好了，此时，我们所需要的，只是写一个ActivityManagerNative的实现类（因为ActivityManagerNative是一个抽象类）。
- 我们可以再来看看ActivityManagerService.java的实现：
#+BEGIN_SRC csharp
// ActivityManagerNative里带抽象标记的方法，都需要在ActivityManagerService里实现
public finalclass ActivityManagerService extends ActivityManagerNative
    implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback { // <<<<<<<<<< 1

    final Handler mHandler= newHandler() { // <<<<<<<<<< 2
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case SHOW_ERROR_MSG: { 
                HashMap data = (HashMap)msg.obj;
                synchronized(ActivityManagerService.this) {
                    ProcessRecord proc =(ProcessRecord)data.get("app");
                    if (proc != null &&proc.crashDialog != null) {
                        Slog.e(TAG, "App already has crash dialog: " + proc);
                        return;
                    }
                    AppErrorResult res =(AppErrorResult) data.get("result");
                    if (mShowDialogs &&!mSleeping && !mShuttingDown) {
                        Dialog d = newAppErrorDialog(mContext, res, proc);
                        d.show();
                        proc.crashDialog = d;
                    } else {
                        res.set(0);
                    }
                }               
                ensureBootCompleted();
            } break;
            }
        };
    }
    @Override
        public boolean onTransact(int code, Parcel data,Parcel reply,int flags) throws RemoteException { // <<<<<<<<<< 3
        if (code == SYSPROPS_TRANSACTION) {// ...}
            try {
                return super.onTransact(code, data, reply, flags);
            } catch (RuntimeException e) {
                if (!(e instanceof SecurityException)) 
                    Slog.e(TAG, "Activity Manager Crash", e);
                throw e;
            }
        }
    }

    // 涉及安全的功能，最需要在Intent分发时便被处理
    // 系统其他部分，则可以统一通过对IPermissionController远程接口的访问，得到权限验证功能。
    static class PermissionController extends IPermissionController.Stub { // <<<<<<<<<< 4
        ActivityManagerService mActivityManagerService;
        PermissionController(ActivityManagerService activityManagerService) {
            mActivityManagerService =activityManagerService;
        }
        public boolean checkPermission(String permission,int pid, int uid) {
            return mActivityManagerService.checkPermission(permission, pid, uid)
                == PackageManager.PERMISSION_GRANTED;
        }
    }

    // 提供Service的“监护”功能:
    // 当某一个Service处于Bounded生命周期内，又因为出错退出，或是由于系统资源不够被回收时，
    // ServiceRestarter对象则会将Service进行重启
    private class ServiceRestarter implements Runnable { // <<<<<<<<<< 5
        private ServiceRecord mService;
        void setService(ServiceRecord service) {
            mService = service;
        }
        public void run() {
            synchronized(ActivityManagerService.this) {
                performServiceRestartLocked(mService);
            }
        }
    }

    public finalint startActivity(IApplicationThread caller, // <<<<<<<<<< 6
                                  Intent intent, String resolvedType, IBinder resultTo,
                                  String resultWho, int requestCode,int startFlags,      
                                  StringprofileFile, ParcelFileDescriptor profileFd, Bundle options) {
        enforceNotIsolatedCaller("startActivity");
        int userId = 0;
        if (intent.getCategories() != null && intent.getCategories().contains(Intent.CATEGORY_HOME)) {
            userId = mCurrentUserId;
        } else {
            if (Binder.getCallingUid() < Process.FIRST_APPLICATION_UID) {
                userId = 0;
            } else userId =Binder.getOrigCallingUser();
        }
        return mMainStack.startActivityMayWait(caller, -1, intent, resolvedType,
                                               resultTo, resultWho, requestCode, startFlags, profileFile, profileFd,
                                               null, null, options, userId);
    }
    
    public int bindService(IApplicationThread caller, IBinder token, // <<<<<<<<<< 7
                           Intent service, String resolvedType,
                           IServiceConnection connection, int flags,int userId) {
        enforceNotIsolatedCaller("bindService");
        if (service != null && service.hasFileDescriptors() == true) 
            throw new IllegalArgumentException("File descriptors passed in Intent");
        checkValidCaller(Binder.getCallingUid(), userId);
 
        synchronized(this) {
            final ProcessRecord callerApp = getRecordForAppLocked(caller);
            if (callerApp == null) {
                throw new SecurityException(
                    "Unable to find app for caller " + caller
                    + " (pid=" +Binder.getCallingPid()
                    + ") when binding service " + service);
            }
 
            ActivityRecord activity = null;
            if (token != null) {
                activity = mMainStack.isInStackLocked(token);
                if (activity == null) {
                    Slog.w(TAG, "Binding with unknown activity: " + token);
                    return 0;
                }
            }
 
            PendingIntent clientIntent = null;
            int clientLabel = 0;
            if (callerApp.info.uid == Process.SYSTEM_UID) {
                try {
                    clientIntent = (PendingIntent)service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);
                } catch (RuntimeException e) {}
                if (clientIntent != null) {
                    clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, 0);
                    if (clientLabel != 0) 
                        service =service.cloneFilter();
                }
            }
           
            ServiceLookupResult res = retrieveServiceLocked(
                service,resolvedType, Binder.getCallingPid(),Binder.getCallingUid(), userId);
            if (res == null) return 0;
            if (res.record == null) return -1;
            if (isSingleton(res.record.processName, res.record.appInfo)) {
                userId = 0;
                res = retrieveServiceLocked(
                    service, resolvedType, Binder.getCallingPid(),
                    Binder.getCallingUid(),0);
            }
            ServiceRecord s = res.record;
            final long origId = Binder.clearCallingIdentity();
 
            if (unscheduleServiceRestartLocked(s)) 
                if (DEBUG_SERVICE) Slog.v(TAG,"BIND SERVICE WHILE RESTART PENDING:" + s);
 
            AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);
            ConnectionRecord c = new ConnectionRecord(
                b, activity, connection, flags,clientLabel, clientIntent);
 
            IBinder binder = connection.asBinder();
            ArrayList<ConnectionRecord> clist = s.connections.get(binder);
            if (clist == null) {
                clist = new ArrayList<ConnectionRecord>();
                s.connections.put(binder,clist);
            }
            clist.add(c);
            b.connections.add(c);
            if (activity != null) {
                if (activity.connections == null) 
                    activity.connections = new HashSet<ConnectionRecord>();
                activity.connections.add(c);
            }
            b.client.connections.add(c);
            if ((c.flags&Context.BIND_ABOVE_CLIENT) != 0) 
                b.client.hasAboveClient = true;
            clist = mServiceConnections.get(binder);
            if (clist == null) {
                clist = newArrayList<ConnectionRecord>();
                mServiceConnections.put(binder,clist);
            }
            clist.add(c);
 
            if ((flags&Context.BIND_AUTO_CREATE) != 0) {
                s.lastActivity =SystemClock.uptimeMillis();
                if (!bringUpServiceLocked(s,service.getFlags(),false)) 
                    return 0;
            }
            if (s.app != null) 
                // This could have made the service more important.
                updateOomAdjLocked(s.app);
 
            if (DEBUG_SERVICE) Slog.v(TAG, "Bind" + s + "with " + b
                                      + ": received=" +b.intent.received
                                      + " apps=" +b.intent.apps.size()
                                      + " doRebind=" +b.intent.doRebind);
             if (s.app != null && b.intent.received) {
                try {
                    c.conn.connected(s.name,b.intent.binder);
                } catch (Exception e) {
                    Slog.w(TAG, "Failure sending service " + s.shortName
                           + " to connection " + c.conn.asBinder()
                           + " (in " +c.binding.client.processName +")", e);
                }
                if (b.intent.apps.size() ==1 &&b.intent.doRebind) 
                    requestServiceBindingLocked(s, b.intent, true);
            } else if (!b.intent.requested) 
                requestServiceBindingLocked(s,b.intent, false);
            Binder.restoreCallingIdentity(origId);
        }
        return 1;
    }
 
    public final int broadcastIntent(IApplicationThread caller, // <<<<<<<<<< 8
                                     Intent intent, String resolvedType, IIntentReceiver resultTo,
                                     int resultCode, String resultData, Bundle map,
                                     String requiredPermission, boolean serialized, boolean sticky, int userId) {
        enforceNotIsolatedCaller("broadcastIntent");
        synchronized(this) {
            intent = verifyBroadcastLocked(intent);
            final ProcessRecord callerApp = getRecordForAppLocked(caller);
            final int callingPid = Binder.getCallingPid();
            final int callingUid = Binder.getCallingUid();
            final long origId = Binder.clearCallingIdentity();
// <<<<<<<<<<<<<<<<<<<< 通过内部实现的broadcastIntentLocked()来进行互斥性的消息发送
            int res = broadcastIntentLocked(callerApp, 
                                            callerApp != null ? callerApp.info.packageName :null,
                                            intent, resolvedType,resultTo,
                                            resultCode, resultData,map, requiredPermission, serialized, sticky,
                                            callingPid, callingUid,userId);
            Binder.restoreCallingIdentity(origId);
            return res;
        }
    }
    
    private final int computeOomAdjLocked( // 计算OOM_ADJ
        ProcessRecord app, int hiddenAdj,
        ProcessRecord TOP_APP, boolean recursed, boolean doingAll) { // <<<<<<<<<< 9
        return app.curRawAdj;
    }
 
    final void performAppGcLocked(ProcessRecord app) { // <<<<<<<<<< 10
        try {
            app.lastRequestedGc = SystemClock.uptimeMillis();
            if (app.thread != null) 
                if (app.reportLowMemory) {
                    app.reportLowMemory = false;
                    app.thread.scheduleLowMemory();
                } else app.thread.processInBackground();
        } catch (Exception e) {} // whatever. 
    }
}
#+END_SRC 
- ActivityManagerService最终会是一个实现ActivityManagerNative接口方法的类， *ActivityManagerNative里带抽象标记的方法，都需要在ActivityManagerService里实现* 。
  - 虽然 *基本的Binder接收端处理也还是在ActivityManagerNative类里实现的* ，但由于 *直接使用ActivityManagerNative类的地方，并不能将这一抽象类实例化* ，
  - 于是在 *客户端实际上只能得到ActivityManagerProxy* ，
  - 而 *服务端则可以通过ActivityManagerService得到具体的IActivityManager接口的Service实例* 。
  - 这样的 *代码实现* 则 *使构建在Binder收发两端的代码逻辑都被统一起来* ， *同时也可以在运行时通过不同的实例化能力被拆分开。*
  - 由于 *ActivityManager还需要提供其他部分的交互功能* ，于是不光是实现 *ActivityManagerNative* 抽象类，同时还会实现 *Watchdog.Monitor*,和 *BatteryStatsImpl.BatteryCallback* 这两个接口对象。
- Handler对象。在Android世界里，Handler对象是多线程处理上的一种异常灵活的机制，Handler会与创建它的线程，以及这一线程所附带的MessageQueue绑定。而拥有Handler对象的线程，则具备从MessageQueue中取出消息进行处理的能力，如果Message本身是一个Runnable对象，则可以在当前线程内执行某种操作。这样的机制应用程序的多线程编程时多用于后台线程回调到UI主线程里，但在Android系统里，也会大量使用这种机制，实现消息管理上的灵活处理。Handler通过postMessage()方法将Message插入MessageQueue，而通过handleMessage()将消息取出并处理，而在一个Handler对象的实现里，一般只需要实现handleMessage()方法。
- 覆盖onTransact()方法。如我们前面所述的IoC模式在设计上的妙用，于是我们每次继承某个基类时，我们都有可能通过覆盖方法+反向调用的方式实现对基类的原有方法的动态拓展。在Android系统里，这一技巧被反复使用，我们即可以在父类方法之后添加一些新的处理，也可以将新加的处理插到父类方法处理之前，唯一做不到的是在父类方法执行中插入新的处理。当然，基于Binder的收发处理上有其特殊性，在ActivityManagerService里拓展的onTransact()处理，并没有公布出来，客户端的transact()并不会分发这样的消息，于是我们也可以认为这一种类似于private限定的RPC，可以通过特殊路径来发送这样拓展出来的Message，供内部使用。
- 内部实现的IPermissionController的Stub对象。IPermissionController实际上只需要一个接口方法，checkPermission()，这一部分涉及安全的功能，最需要在Intent分发时便被处理，于是我们就在ActivityManagerService里实现。而系统其他部分，则可以统一通过对IPermissionController远程接口的访问，得到权限验证功能。
- ServiceRestarter对象，则提供Service的“监护”功能，当某一个Service处于Bounded生命周期内，又因为出错退出，或是由于系统资源不够被回收时，ServiceRestarter对象则会将Service进行重启。
- startActivity()。应用程序里一般会通过Context.startActivity()将Intent发送出来，但实际上会通过IActivityManager这一接口，将消息发送到ActivityManagerNative。在ActivityManagerNative的onTransact()方法里会再调用一个它自己并没有实现，而在继承它的ActivityManagerService里实现的startActivity()，也就是我们这里看到的这一方法，通过ActivityStack来找到合适的Activity来响应Intent消息的请求。
- bindService ()。因为我们前面以RemoteService为例，于是我们这里看看bindService()的实现（Remote Service必须以BoundedService为其生存期）。与Activity不同，Service不需要栈式管理，但需要更严格的并发控制，于是可以看到在整个bindService()实现里，都使用了synchronized限制符用于线程并发同步。在整个Service引用的获取过程里，差不多都是检测当前环境里是否已经存在所需要的Service，如果没有，则尝试启动它。
- broadcastIntent()。与bindService()类似，既然我们可以使用Intent来启动合适的Service，同理我们也可以使用Intent来驱动Broadcast Receiver。在广播消息发送时，会通过内部实现的broadcastIntentLocked()来进行互斥性的消息发送。而在broadcastIntentLocked()里，则会对系统发送的Intent进行一系列特殊的操作，然后针对 sticky方式发送的Intent进行专门的处理，最后便会调用PackageManager来取得系统里会接收这一Intent的Receiver，然后再将消息发送到这些进程的MessageQueue。
- 计算OOM_ADJ。在应用程序设计时，我们看到，Android应用程序世界里有一种永不退出的机制，而会在系统内存不够时通过一个OOM_ADJ参数来杀死合适的进程以回收内存，这里便会计算并选择合理的进程。在本质上说，进程本身会通过其是否是处于前台交互，是否与前台交互相关等来确定其优先级，但在执行过程中，还是需要根据其活跃程序来判断是否该杀死该进程，如果这一进程使用频度很高，则杀死该进程则过于浪费系统资源。于是在这一computeOomAdjLocked()方法里，会根据Activity等执行实体在调度上的时间信息来动态调整OOM的相关信息。
- 针对进程进行垃圾回收。与标准Java虚拟机不一样，Android的DalvikVM是以进程为单位来构建虚拟机执行环境的，于是系统里不再有一个统一的Java虚拟机环境，不能进行全局的垃圾回收。于是，在这个performAppGcLocked()方法里，会尝试针对某个进程回收内存。
** 总结
- ActivityManagerService.java实现的代码很长，而且并非独立工作，实际上它只是frameworks/base/services/java/com/android/server/am这个包的调用入口。 *因为IActivityManager这个接口类可以说是整个Android系统的“调度器”，涉及消息分发、进程管理* 。虽然 *这样的把这样大量功能揉合到一起的设计思路并不是很优雅，也不够低耦合* ，但 *从整个系统构建来看，这样的设计便很好地贯彻了简单高效的设计思路。* 
  - 从编程角度来看，事实上， *ActivityManagerService类只不过是ActivityManagerNative接口的具体实现* ，并不难理解。
  - 从 *应用程序* 角度，它会 *直接通过进程内预置的ActivityManagerProxy对象（通过ContextImpl对象来找到）向IActivityManager的Binder接收端发命令* .
  - 如果我们系统里 *有任何一个进程或是线程创建一个ActivityManagerService对象，则所有基于IActivityManager接口进行RPC调用的地方，都将使用这一ActivityManagerService对象响应其执行请求* 。从前面对于Android的进程模型的分析我们也可以看到，完成这样功能的进程会是一个叫 *SystemServer的系统进程* 。于是，所有的分析得到的结果，便是如下这样的执行模型：
    
[[./pic/activityService_20220831_083935.png]]
- *当系统里拥有一个ActivityManagerService的实例，则任何系统组成部分、或是应用程序，都可以使用bindService()取回合适的Binder，然后再通过这一Binder通信管道完成后续的通讯* 。在ActivityManagerService实例存在之后，我们后续的操作就可以都通过aidl的方式来进行了。这种 *使用bindService()的方式，我们在系统里偶尔用到，但并非最常用的一种。*
- 为什么？因为 *这种方式很低效，每次调用前需要通过bindService()来驱动Service的有效bounded生命周期* 。这样的应用情境也存在，比如蓝牙、VPN等功能，系统只是偶尔要使用，使用时通过bindService()来初始化Service的上下文环境，不再用时便可以通过unbindService()取消对Service的引用，从而可以可以按需分配地使用系统提供的各种功能。但对于系统里的绝大部分功能来说，它的生存周期是一直存在的，在系统运行过程里，需要一直给不同执行部分提供其功能。这样的Service不需要生命周期的控制，在系统运行起来后就会一直在系统内存在，全局提供系统内功能的共享。这样的Service，我们一般可以称之为SystemService，它们不再使用bindService()来驱动，而直接通过一个叫ServiceManager的功能部件来实现。

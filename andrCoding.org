#+latex_class: cn-article
#+title: Android Coding Assessment Prepare
#+author: deepwaterooo

* How would you communicate between two Fragments?

All Fragment-to-Fragment communication is done either through a shared ViewModel or through the associated Activity. Two Fragments should never communicate directly.

- The recommended way to communicate between fragments is to create a shared ViewModel object. Both fragments can access the ViewModel through their containing Activity. The Fragments can update data within the ViewModel and if the data is exposed using LiveData the new state will be pushed to the other fragment as long as it is observing the LiveData from the ViewModel.
#+BEGIN_SRC java
public class SharedViewModel extends ViewModel {
    private final MutableLiveData <Item> selected = new MutableLiveData < Item > ();
    public void select(Item item) {
        selected.setValue(item);
    }
    public LiveData <Item> getSelected() {
        return selected;
    }
}
public class MasterFragment extends Fragment {
    private SharedViewModel model;
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        itemSelector.setOnClickListener(item -> {
                model.select(item);
            });
    }
}
public class DetailFragment extends Fragment {
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        model.getSelected().observe(this, {
                item ->
                    // Update the UI.
                    // model.select(item); // ËøôË°åÂÖÖÂΩìÂç†‰ΩçÁ¨¶ÔºåÂ§çÂà∂ÁöÑ‰∏äÈù¢ÁöÑ
                    });
    }
}
#+END_SRC
- Another way is to define an interface in your Fragment A, and let your Activity implement that Interface. Now you can call the interface method in your Fragment, and your Activity will receive the event. Now in your activity, you can call your second Fragment to update the textview with the received value.

* What are Retained Fragments?
- By default, Fragments are destroyed and recreated along with their parent Activity‚Äôs when a configuration change occurs.
- Calling setRetainInstance(true) allows us to bypass this destroy-and-recreate cycle, signaling the system to retain the current instance of the fragment when the activity is recreated.

* What are the permission protection levels in Android?
- Normal ‚Äî A lower-risk permission that gives requesting applications access to isolated application-level features, with minimal risk to other applications, the system, or the user. The system automatically grants this type of permission to a requesting application at installation, without asking for the user‚Äôs explicit approval.
- Dangerous ‚Äî A higher-risk permission. Any dangerous permissions requested by an application may be displayed to the user and require confirmation before proceeding, or some other approach may be taken to avoid the user automatically allowing the use of such facilities.
- Signature ‚Äî A permission that the system grants only if the requesting application is signed with the same certificate as the application that declared the permission. If the certificates match, the system automatically grants the permission without notifying the user or asking for the user‚Äôs explicit approval.
- SignatureOrSystem ‚Äî A permission that the system grants only to applications that are in the Android system image or that are signed with the same certificate as the application that declared the permission.

* What is Android Data Binding?

The Data Binding Library is a support library that allows you to bind UI components in your layouts to data sources in your app using a declarative format rather than programmatically.

Layouts are often defined in activities with code that calls UI framework methods. For example, the code below calls findViewById() to find a TextView widget and bind it to the userName property of the viewModel variable:

#+BEGIN_SRC java
TextView textView = findViewById(R.id.sample_text);
textView.setText(viewModel.getUserName());
#+END_SRC

The following example shows how to use the Data Binding Library to assign text to the widget directly in the layout file. This removes the need to call any of the Java code shown above.

#+BEGIN_SRC java
<TextView
    android:text="@{viewmodel.userName}" />
#+END_SRC

- The pros of using Android Data Binding:
  - Reduces boilerplate code which in turns brings
  - Less coupling
  - Stronger readability
  - Powerful, easy to implement custom attribute and custom view
  - Even faster than findViewById - The binding does a single pass on the View hierarchy, extracting the Views with IDs. This mechanism can be faster than calling findViewById for several Views.

* What is the ViewHolder pattern? Why should we use it?

Every time when the adapter calls getView() method, the findViewById() method is also called. This is a very intensive work for the mobile CPU and so affects the performance of the application and the battery consumption increases. ViewHolder is a design pattern which can be applied as a way around repeated use of findViewById().

A ViewHolder holds the reference to the id of the view resource and calls to the resource will not be required after you "find" them: Thus performance of the application increases.
#+BEGIN_SRC java
private static class ViewHolder {
    final TextView text;
    final TextView timestamp;
    final ImageView icon;
    final ProgressBar progress;

    ViewHolder(TextView text, TextView timestamp, ImageView icon, ProgressBar progress) {
        this.text = text;
        this.timestamp = timestamp;
        this.icon = icon;
        this.progress = progress;
    }
}
public View getView(int position, View convertView, ViewGroup parent) {
    View view = convertView;
    if (view == null) {
        view = // inflate new view
        ViewHolder holder = createViewHolderFrom(view);
        view.setTag(holder);  
    }
    ViewHolder holder = view.getTag();
    // TODO: set correct data for this list item
    // holder.icon.setImageDrawable(...)
    // holder.text.setText(...)
    // holder.timestamp.setText(...)
    // holder.progress.setProgress(...)
    return view;
}
private ViewHolder createViewHolderFrom(View view) {
    ImageView icon = (ImageView) view.findViewById(R.id.listitem_image);
    TextView text = (TextView) view.findViewById(R.id.listitem_text);
    TextView timestamp = (TextView) view.findViewById(R.id.listitem_timestamp);
    ProgressBar progress = (ProgressBar) view.findViewById(R.id.progress_spinner);
    return new ViewHolder(text, timestamp, icon, progress);
}
#+END_SRC
- View.setTag(Object) allows you to tell the View to hold an arbitrary object. If we use it to hold an instance of our ViewHolder after we do our findViewById(int) calls, then we can use View.getTag() on recycled views to avoid having to make the calls again and again.

* ActivityÊ®™Á´ñÂ±èÂàáÊç¢ÁîüÂëΩÂë®ÊúüÂèòÂåñ
** Êñ∞Âª∫‰∏Ä‰∏™ActivityÔºåÂπ∂ÊääÂêÑ‰∏™ÁîüÂëΩÂë®ÊúüÊâìÂç∞Âá∫Êù•
onCreate,
ÂàõÂª∫activityÊó∂Ë∞ÉÁî®„ÄÇËÆæÁΩÆÂú®ËØ•ÊñπÊ≥ï‰∏≠ÔºåËøò‰ª•Bundle‰∏≠ÂèØ‰ª•ÊèêÂá∫Áî®‰∫éÂàõÂª∫ËØ• Activity ÊâÄÈúÄÁöÑ‰ø°ÊÅØ„ÄÇ
onStart,
activityÂèò‰∏∫Âú®Â±èÂπï‰∏äÂØπÁî®Êà∑ÂèØËßÅÊó∂ÔºåÂç≥Ëé∑ÂæóÁÑ¶ÁÇπÊó∂Ôºå‰ºöË∞ÉÁî®„ÄÇ
onResume,
activityÂºÄÂßã‰∏éÁî®Êà∑‰∫§‰∫íÊó∂Ë∞ÉÁî®ÔºàÊó†ËÆ∫ÊòØÂêØÂä®ËøòÊòØÈáçÊñ∞ÂêØÂä®‰∏Ä‰∏™Ê¥ªÂä®ÔºåËØ•ÊñπÊ≥ïÊÄªÊòØË¢´Ë∞ÉÁî®ÁöÑÔºâ
onSaveInstanceState
onPause,
activityË¢´ÊöÇÂÅúÊàñÊî∂ÂõûcpuÂíåÂÖ∂‰ªñËµÑÊ∫êÊó∂Ë∞ÉÁî®ÔºåËØ•ÊñπÊ≥ïÁî®‰∫é‰øùÂ≠òÊ¥ªÂä®Áä∂ÊÄÅÁöÑ
onStop,
activityË¢´ÂÅúÊ≠¢Âπ∂ËΩ¨‰∏∫‰∏çÂèØËßÅÈò∂ÊÆµÂèäÂêéÁª≠ÁöÑÁîüÂëΩÂë®Êúü‰∫ã‰ª∂Êó∂ÔºåÂç≥Â§±ÂéªÁÑ¶ÁÇπÊó∂Ë∞ÉÁî®
onDestroy,
activityË¢´ÂÆåÂÖ®‰ªéÁ≥ªÁªüÂÜÖÂ≠ò‰∏≠ÁßªÈô§Êó∂Ë∞ÉÁî®ÔºåËØ•ÊñπÊ≥ïË¢´Ë∞ÉÁî®ÂèØËÉΩÊòØÂõ†‰∏∫Êúâ‰∫∫Áõ¥Êé•Ë∞ÉÁî® finish()ÊñπÊ≥ï ÊàñËÄÖÁ≥ªÁªüÂÜ≥ÂÆöÂÅúÊ≠¢ËØ•Ê¥ªÂä®‰ª•ÈáäÊîæËµÑÊ∫ê„ÄÇ
onRestoreInstanceState,
AndroidÂú®Ê®™Á´ñÊéíÂàáÊç¢Êó∂ÂÄôÔºåÂ∞Ü‰∏ªÂä®ÈîÄÊØÅactivityÂíåÈáçÊñ∞ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑactivityÂá∫Êù•ÔºåÂú®Ê≠§ËøáÁ®ã‰∏≠ÔºåonRestoreInstanceStateÂ∞±Ë¶ÅË¢´ÂõûË∞É
onConfigurationChanged,
ÈÖçÁΩÆÊåáÂÆöÂ±ûÊÄßÂêé,Â±èÂπïÊñπÂêëÂèëÁîüÂèòÂåñÂêéÂõûË∞ÉÊ≠§ÂáΩÊï∞.
** ËøêË°åActivityÔºåÂæóÂà∞Â¶Ç‰∏ã‰ø°ÊÅØ
#+BEGIN_SRC java
onCreate  -->
onStart  -->
onResume  -->
#+END_SRC
** Êåâcrtl+f12ÂàáÊç¢ÊàêÊ®™Â±èÊó∂
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC
** ÂÜçÊåâcrtl+f12ÂàáÊç¢ÊàêÁ´ñÂ±èÊó∂ÔºåÂèëÁé∞ÂèàÊâìÂç∞‰∫ÜÁõ∏ÂêåÁöÑlog
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC
** ‰øÆÊîπAndroidManifest.xml
ÊääËØ•ActivityÊ∑ªÂä†
#+BEGIN_SRC java
android:configChanges="orientation"Ôºå
#+END_SRC
ÊâßË°åÊ≠•È™§3(ÂàáÊç¢ÊàêÊ®™Â±èÊó∂)
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC
** ÂÜçÊâßË°åÊ≠•È™§4(ÂàáÊç¢Á´ñÂ±è)ÔºåÂèëÁé∞ÂÜçÊâìÂç∞Áõ∏Âêå‰ø°ÊÅØ
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC

* What is the difference between Handler vs AsyncTask vs Thread?
Mid 
Top 113 Android Interview Questions  Android  113  
Answer
The Handler class can be used to register to a thread and provides a simple channel to send data to this thread. A Handler allows you communicate back with the UI thread from other background thread.
The AsyncTask class encapsulates the creation of a background process and the synchronization with the main thread. It also supports reporting progress of the running tasks.
And a Thread is basically the core element of multithreading which a developer can use with the following disadvantage:
Handle synchronization with the main thread if you post back results to the user interface
No default for canceling the thread
No default thread pooling
No default for handling configuration changes in Android
Having Tech or Coding Interview? Check üëâ 113 Android Interview Questions
Source: stackoverflow.com
* What is the difference between compileSdkVersion and targetSdkVersion?
Mid 
Top 113 Android Interview Questions  Android  113  
Answer
The compileSdkVersion is the version of the API the app is compiled against. This means you can use Android API features included in that version of the API (as well as all previous versions, obviously). If you try and use API 16 features but set compileSdkVersion to 15, you will get a compilation error. If you set compileSdkVersion to 16 you can still run the app on a API 15 device as long as your app's execution paths do not attempt to invoke any APIs specific to API 16.

The targetSdkVersion has nothing to do with how your app is compiled or what APIs you can utilize. The targetSdkVersion is supposed to indicate that you have tested your app on (presumably up to and including) the version you specify. This is more like a certification or sign off you are giving the Android OS as a hint to how it should handle your app in terms of OS features.
* What is the difference between a Bundle and an Intent?
Mid 
Top 113 Android Interview Questions  Android  113  
Answer
A Bundle is a collection of key-value pairs.
However, an Intent is much more. It contains information about an operation that should be performed. This new operation is defined by the action it can be used for, and the data it should show/edit/add. The system uses this information for finding a suitable app component (activity/broadcast/service) for the requested action.
Think of the Intent as a Bundle that also contains information on who should receive the contained data, and how it should be presented.


* È°πÁõÆ‰∏≠Áî®Âà∞ÁöÑÂ∞èÁÇπ
#+BEGIN_SRC xm
android.useAndroidX=true
landroid.enableJetifier=true
#+END_SRC

- ‰ªÄ‰πàÊòØJetifierÔºü ‰æãÂ¶ÇÔºåË¶Å‰ΩøÁî®androidxÊâìÂåÖÁöÑ‰æùËµñÈ°πÂàõÂª∫Êñ∞È°πÁõÆÔºåÊ≠§Êñ∞È°πÁõÆÈúÄË¶ÅÂú®gradle.propertiesÊñá‰ª∂‰∏≠Ê∑ªÂä†‰ª•‰∏ãË°åÔºö

java version 8
 compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.snackbar.Snackbar;

    <com.me.generalprac.CustomTitleView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
    <include layout="@layout/custom_title"/>


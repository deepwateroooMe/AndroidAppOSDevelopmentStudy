#+latex_class: cn-article
#+title: 安卓中的线程、异步任务、Service与IntentService
#+author: deepwaterooo

* Java 创建线程的三种方式总结
- https://blog.csdn.net/u011578734/article/details/110523825
** 继承 Thread 类
   #+BEGIN_SRC java
class MyThread extends Thread {
    @Override
        public void run() {
        super.run();
    }
}
private void testThread(){
    Thread thread = new MyThread();
    thread.start();
}
   #+END_SRC
- 缺点: Java 的单继承限制，想通过 Thread 实现多线程，就只能继承 Thread 类，不可继承其他类。
** 实现 Runnable 接口
- 如果自己的类已经继承了其他类，这时就只能通过实现 Runnable 接口来实现多线程了。
- 不过，继承 Runnable 接口后，想要启动线程，需要把该类的对象作为参数，传递给 Thread 的构造函数，并使用 Thread 类的实例方法 start 来启动。
#+BEGIN_SRC java
public class TestThread extends A implements Runnable {
    public void run() {
        // todo
    }
}
// 启动线程
TestThread testThread = new TestThread();
Thread thread = new Thread(testThread);
thread.start();
#+END_SRC
- Thread 内部的 run 方法我们可以看到它的实现原理：
#+BEGIN_SRC java
private Runnable target;
public void run() {
    if (target != null) {
        target.run();
    }
}
#+END_SRC
- target 是我们传递进来的 Runnable 对象，当线程执行时，线程的 run 方法会直接调用 Runnable 对象的 run 方法。
** 实现 Callable 接口
- 如果想要执行的线程有返回，怎么处理呢？这时应该使用 Callable 接口了，与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。
#+BEGIN_SRC java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 111;
    }
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
#+END_SRC
** 比较
- 这几种线程创建方式中，实现接口会更好一些，因为：
  - Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口。
  - 类可能只要求可执行就行，继承整个 Thread 类开销过大。
  - 另外，如果需要有返回值时，使用 Callable 接口是适合的。


* Handler的使用
- Android中，不允许应用程序在子线程中更新UI，UI的处理必须在UI线程中进行，这样Android定制了一套完善的线程间通信机制——Handler通信机制。Handler作为Android线程通信方式，高频率的出现在我们的日常开发工作中，我们常用的场景包括：使用异步线程进行网络通信、后台任务处理等，Handler则负责异步线程与UI线程（主线程）之间的交互。
- Android为了确保UI操作的线程安全，规定所有的UI操作都必须在主线程（UI线程）中执行，决定了UI线程中不能进行耗时任务，在开发过程中，需要将网络，IO等耗时任务放在工作线程中执行，工作线程中执行完成后需要在UI线程中进行刷新，因此就有了Handler进程内线程通信机制，当然Handler并不是只能用在UI线程与工作线程间的切换，Android中任何线程间通信都可以使用Handler机制。
** UI线程中使用Handler
- UI线程中使用Handler非常简单，因为框架已经帮我们初始化好了Looper,只需要创建一个Handler对象即可，之后便可以直接使用这个Handler实例向UI线程发消息（子线程--->UI线程）
#+BEGIN_SRC java
    private Handler handler = new Handler(){
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);
            //处理消息
        }
    };
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_six);
    }
#+END_SRC
- 这种方式会导致 _内存泄露_ 。
- Handler 内存泄漏的两个原因: 
  - Java 中非静态内部类和匿名内部类会持有外部类的引用
#+BEGIN_SRC java
// 这是一个外部类 Handler 不会持有外部类引用
// 显然 handleMessage 没地方写了
Handler handler = new Handler();

// 重写 handleMessage 后将得到一个内部类 Handler，以内 handleMessage 是在外部类中实现的
// 它持有外部类引用，可能会引起内存泄漏
Handler handler = new Handler() { // 这是重写了handleMessage后的内部类Handler
  @Override public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what) {
            case 0:
              MLog.i(msg.obj);
              break;
            case 1:
              break;
            default:

        }
    }
};

// 这里 Handler 是一个匿名类，但不是内部类
// Runnable 是一个匿名内部类，持有外部类引用，可能会引起内存泄漏
new Handler().post(new Runnable() {
    @Override public void run() {
      // ...
    }
});
#+END_SRC 
  - Handler 的生命周期比外部类长
  - 我们通过Handler发送消息，在Message对象中会持有当前Handler对象的引用，在Java中非静态成员类、内部类、匿名类会持有外部对象的引用（这里在源码中有提到），而Looper是线程局部变量，其生命周期与UI线程相同，Looper持有MessageQueue的引用，MessageQueue持有Message的引用，当通过Handler发送一个延时消息未处理之前用户已经离开当前Activity，会导致Activity不能及时释放而内存泄漏。
- 分析
  - 非静态的内部 Handler 子类、匿名 Handler 子类会持有外部类的引用(Activity)，而 Handler 可能会因为要等待处理耗时操作导致存活时间超过 Activity，或者消息队列中存在未被 Looper 处理的 Message ，而 Message 会持有 Handler 的引用。于是，在 Activity 退出时，其引用还是被 Handler 持有，导致 Activity 无法被及时回收，造成内存泄露。
  - 非静态的内部 Runnable 子类、匿名 Runnable 子类 post 到任意 Handler 上时，Runnable 其实是 Massage中的 Callback，持有 Message 引用，如果这个 Massage 在消息队列还没有被处理，那么就会造成 Runnable 一直持有外部类的引用而造成内存泄露。
*** 解决思路
- 通过静态内部类或者外部类来声明 Handler 和 Runnable，然后使用弱引用来拿到外部类的变量。
- 在 Activity/Fragment 销毁的时候请空 MessageQueue 中的消息。
**** 官方推荐的一种
    #+BEGIN_SRC java
private Handler handler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(@NonNull Message msg) {
            switch (msg.what){
            case 1:
            //处理子线程发过来的消息
            Toast.makeText(SixActivity.this,(String)msg.obj,Toast.LENGTH_LONG).show();
            Log.d("aa",(String) msg.obj);
            break;

            }
            return false;
        }
    });
    #+END_SRC
**** 静态内部类
- 下面的例子实现了子线程（执行run()耗时函数的线程）向主线程发送消息
  #+BEGIN_SRC java
public static final int LOAD_COM = 1; // 加载任务的id标志

private Handler mHandler = new MyHandler(MainActivity.this); // 在MainActivity中，创建了一个Handler对象。

private static class MyHandler extends Handler { // MainActivity中的静态static内部类
    private final WeakReference<MainActivity> mActivity; // 持有当前MainActivity的WeakReference
    private MyHandler(MainActivity activity) {
        this.mActivity = new WeakReference(activity);
    }
    @Override public void handleMessage(@NonNull Message msg) { // ui线程中，负责消息返回的处理逻辑
        super.handleMessage(msg);      // UI线程中，Handler对象的handleMessage方法负责处理消息的返回
        switch (msg.what){
        case LOAD_COM:
            Log.d("TestHandler", msg.obj.toString());
            MainActivity mainActivity = mActivity.get();
            if (mainActivity != null){
                mainActivity.mTextView.setText(msg.obj.toString());
            }
            break;
        }
    }
};
@Override public void onClick(View v) {
    switch (v.getId()) {
    case R.id.start_load: // 当按钮start_load点击时，启动一个后台线程，模拟一个后台加载过程（线程休眠1秒）
        new Thread() {
            @Override
            public void run() { // 后台线程中执行的逻辑：这里代码写定义在主线程MainActivity中，但实际run()函数的真正执行是执行在子线程中
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
// 子线程发送消息
                // Message message = new Message();//可以使用new Message来创建消息，但是一般不这样使用？
                Message message = Message.obtain(); // 后台任务完成后，使用Handler对象的sendMessage方法发送消息（一个Messaage对象）给UI线程
                message.what = LOAD_COM;
                message.obj = "我是子线程消息";
                mHandler.sendMessage(message); // 从后台线程中，发送消息给UI线程
            }
        }.start();
        break;
    }
}
  #+END_SRC
- 主线程给子线程发送消息（UI线程--->子线程）
  #+BEGIN_SRC java
public class SixActivity extends AppCompatActivity {
    private Handler handler;
    private Button btn;
    @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_six);
        new MyOneThread().start();     // 子线程创建方式
        btn= findViewById(R.id.dian);
        btn.setOnClickListener(new View.OnClickListener() {
                @Override
                    public void onClick(View v) {
                    Message message=Message.obtain();
                    message.what=1;
                    message.obj = "我是主线程的消息发送给子线程";
                    handler.sendMessage(message); // 封装完数据发送给子线程
                }
            });
    }
    class MyOneThread extends Thread {
        @Override public void run() {
            // 在子线程中处理消息,子线程中处理消息，没有默认的Loop
            // 由于只有主线程成才默认的Looper.prepare(), Looper.loop();
            Looper.prepare(); // 创建Looper: 如果不添加会报错
            handler = new Handler() { // 在子线程中创建消息Handler
                @Override
                public void handleMessage(@NonNull Message msg) {
                    switch (msg.what){
                    case 1:
                    Log.d("aa",(String) msg.obj);
                    break;
                    }
                }
            };
            // 循环读取messageQueue
            Looper.loop(); // 如果不添加读取不到消息
        }
    }
}
  #+END_SRC
- 子线程中，也可以使用这个方式来获取Looper
#+BEGIN_SRC java
handler = new Handler(Looper.getMainLooper()) {
    @Override
    public void handleMessage(@NonNull Message msg) {
        switch (msg.what) {
        case 1:
        Log.d("aa",(String) msg.obj);
        break;
        }
    }
};
#+END_SRC
- 子线程发送消息到子线程（子线程----->子线程）
#+BEGIN_SRC java
btn.setOnClickListener(new View.OnClickListener() {
        @Override public void onClick(View v) {
            new Thread(new Runnable() {
                    @Override
                    public void run() {
                        Message message = Message.obtain();
                        message.obj = "我是子线程发送到子线消息";
                        message.what = 1;
                        handler.sendMessage(message); // 发送消息的子线程也是有handler的
                    }
                }).start();
        }
    });
class MyOneThread extends Thread {
    @Override public void run() {
        //在子线程中处理消息,子线程中处理消息，没有默认的Loop
        //由于只有主线程成才默认的Looper.prepare(), Looper.loop();
        // Looper.prepare(); // 创建Looper： 效果一样，换下面的方式
        handler = new Handler(Looper.getMainLooper()){
            @Override
            public void handleMessage(@NonNull Message msg) {
                switch (msg.what){
                case 1:
                Log.d("aa",(String) msg.obj);
                break;
                }
            }
        };
        // Looper.loop(); // 循环读取messageQueue
    }
}
#+END_SRC
- 使用Handler.post()直接更新ui
#+BEGIN_SRC java
private Handler handler=new Handler();
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_six);
    btn = findViewById(R.id.dian);
    new Thread(new Runnable() {
            @Override
            public void run() {
                // Message message=Message.obtain();
                // message.obj="我是子线程静态消息";
                // message.what=1;
                // handler.sendMessage(message);
                handler.post(new Runnable() {
                        @Override
                        public void run() {
                            Log.d("aa","直接更新Ui");
                            btn.setText("我是更新的消息");
                        }
                    });
            }
        }).start();
}
#+END_SRC
- post和sendMessage本质上是没有区别的，只是实际用法中有一点差别
- post也没有独特的作用，post本质上还是用sendMessage实现的，post只是一中更方便的用法而已
  
[[./pic/handler.png]]

** 关于安卓handler的面试小问题
*** Looper和Handler一定要处于一个线程吗？子线程中可以用MainLooper去创建Handler吗？
- （1）子线程中
#+BEGIN_SRC java
Handler handler = new Handler(Looper.getMainLooper()); // 此时,子线程的handler与Looper.getMainLooper()主线程Looper, 两者就不在一个线程中
#+END_SRC
  - 此时两者就不在一个线程中
- （2）子线程中可以用MainLooper去创建Handler.
*** Handler的post方法发送的是同步消息吗？可以发送异步消息吗？
- 用户层面发送的都是同步消息
- 不能发送异步消息
- 异步消息只能由系统发送。
*** Handler.post的逻辑在哪个线程执行的，是由Looper所在线程还是Handler所在线程决定的？
- 由Looper所在线程决定的
- 最终逻辑是在Looper.loop()方法中，从MsgQueue中拿出msg，并且执行其逻辑，这是在Looper中执行的，因此是由Looper所在的线程决定的。
*** Handler构造方法中通过Looper.myLooper();是如何获取到当前线程的Looper的？
- myLooper()内部使用ThreadLocal实现，因此能够获取各个线程自己的Looper
*** MessageQueue(消息队列)
- 消息队列被封装到Looper里面了，我们一般不会直接与MessageQueue打交道。我们只需要记住它是用来存放消息的单链表结构。队列的顺序由Message的next属性来维护。MessageQueue是整个Handler机制的核心，里面涉及很多特性我们这里都不展开讲述(比如消息屏障机制)。

** handler工作原理总结： Handler的工作原理
- Handler机制整体流程；
  - IdHandler(闲时机制）；
  - postDelay()的具体实现；
  - post()与sendMessage()区别；
  - 使用Handler需要注意什么问题，怎么解决的?
- 问题很细，能准备多详细就准备多详细。人家自己封装了一套 Handler 来避免内存泄漏问题
- Handler的消息传递机制涉及到四个部分：
  - 1. Message：线程间传递的对象。
  - 2. MessageQueue： 消息队列，用来存放Handler发布的Message.
  - 3. Handler：负责将Message插入到MessageQueue中以及对MessageQueue中的Message进行处理。
  - 4. Looper：负责从MessageQueue中取出Message，并交给Handler.
- 其中：
  -  Looper存储在ThreadLocal中，Looper在创建时会同时创建MessageQueue，作为其成员对象.因此Looper和MessageQueue是属于创建者线程的，各线程之间的Looper和MessageQueue相互独立。
  - Handler在创建时会从当前线程的ThreadLocal中取得Looper.
  - 发送消息时，在发送线程中调用接收线程中的Handler的sendMessage方法，过程中，Handler会将自身赋予到Message的target中，并将Message插入到Handler对应的MessageQueue中。
  - 而接收线程中的Looper在循环过程中会取出这个Message，通过Message.target取出接收线程中的Handler，并将消息交Handler对象处理。由此实现了跨线程通信。
  - 要注意的是：线程与Looper和MessageQueue是一对一的关系，即一个线程只维护一个Looper和一个MessageQueue;而线程与Handler的关系是一对多，即一个线程可以有很多Handler，一个Handler只对应一个线程，这也是为什么Handler在发送消息时，为什么要将自身赋给Message.target的原因。
- Handler内存泄露的解决方法
  - 方法1：通过程序逻辑进行保护。
    - 关闭Activity的时候停掉后台线程，这样就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。
    - 如果你的Handler是被delay的Message持有了引用，那么在Activity销毁前使用相应的Handler的removeCallbacksAndMessages()方法，把消息对象从消息队列移除就行了。
  - 方法2：将Handler声明为静态类
    - 静态类不持有外部类的对象，这样即使Handler在运行，Activity也可以被回收。
    - 由于静态类的Handler不再持有外部类对象，如果要操作Activity需要增加一个Activity的弱引用。
- 优点：
  - 操作简单，无学习成本。
- 缺点：
  - 代码规范性较差，不易维护。
  - 每次操作都会开启一个匿名线程，系统开销较大。
*** Looper.loop()为什么不会阻塞主线程?
- https://segmentfault.com/a/1190000037449196 这部分格式再整理一下
主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。

主线程中如果没有looper进行循环，那么主线程一运行完毕就会退出。那么我们还能运行APP吗，显然，这是不可能的，Looper主要就是做消息循环，然后由Handler进行消息分发处理，一旦退出消息循环，那么你的应用也就退出了。

总结：Looper的无限循环必不可少。

补充说明：

我看有一部分人理解”Looper.loop()的阻塞“和”UI线程上执行耗时操作卡死“的区别时还一脸懵逼的状况，简单回答一波：

首先这两之间一点联系都没有，完全两码事。
Looper上的阻塞，前提是没有输入事件，MsgQ为空，Looper空闲状态，线程进入阻塞，释放CPU执行权，等待唤醒。
UI耗时导致卡死，前提是要有输入事件，MsgQ不为空，Looper正常轮询，线程并没有阻塞，但是该事件执行时间过长（5秒？），而且与此期间其他的事件（按键按下，屏幕点击..）都没办法处理（卡死），然后就ANR异常了。
*** Android -- Looper.prepare()和Looper.loop() —深入版
Android中的Looper类，是用来封装消息循环和消息队列的一个类，用于在android线程中进行消息处理。handler其实可以看做是一个工具类，用来向消息队列中插入消息的。

​ (1) Looper类用来为一个线程开启一个消息循环。 默认情况下android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环。） Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。

(2) 通常是通过Handler对象来与Looper进行交互的。Handler可看做是Looper的一个接口，用来向指定的Looper发送消息及定义处理方法。 默认情况下Handler会与其被定义时所在线程的Looper绑定，比如，Handler在主线程中定义，那么它是与主线程的Looper绑定。 mainHandler = new Handler() 等价于new Handler（Looper.myLooper()）. Looper.myLooper()：获取当前进程的looper对象，类似的 Looper.getMainLooper() 用于获取主线程的Looper对象。

(3) 在非主线程中直接new Handler() 会报如下的错误:

E/AndroidRuntime( 6173): Uncaught handler: thread Thread-8 exiting due to uncaught exception E/AndroidRuntime( 6173): java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()

原因是非主线程中默认没有创建Looper对象，需要先调用Looper.prepare()启用Looper。

(4) Looper.loop();

让Looper开始工作，从消息队列里取消息，处理消息。

注意：写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。
(5) 基于以上知识，可实现主线程给子线程（非主线程）发送消息。

*** 线程的切换又是怎么回事？
那么线程的切换又是怎么回事呢？
很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下：

Thread.foo(){
    Looper.loop()
     -> MessageQueue.next()
      -> Message.target.dispatchMessage()
       -> Handler.handleMessage()
}
显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。

平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 handleMessage() 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。
*** Handler是如何实现线程之间的切换的
Handler是如何实现线程之间的切换的呢？例如现在有A、B两个线程，在A线程中有创建了handler，然后在B线程中调用handler发送一个message。

通过上面的分析我们可以知道，当在A线程中创建handler的时候，同时创建了MessageQueue与Looper，Looper在A线程中调用loop进入一个无限的for循环从MessageQueue中取消息，当B线程调用handler发送一个message的时候，会通过msg.target.dispatchMessage(msg);将message插入到handler对应的MessageQueue中，Looper发现有message插入到MessageQueue中，便取出message执行相应的逻辑，因为Looper.loop()是在A线程中启动的，所以则回到了A线程，达到了从B线程切换到A线程的目的。

image

小结：

1.Handler初始化之前，Looper必须初始化完成。UI线程之所以不用初始化，因为在ActivityThread已经初始化，其他子线程初始化Handler时，必须先调用Looper.prepare()。

2.通过Handler发送消息时，消息会回到Handler初始化的线程，而不一定是主线程。

3.使用ThreadLocal时，需要注意内存泄漏的问题。

通俗点的说法Handler机制其实就是借助共享变量来进行线程切换的.

Handler是如何实现线程之间的切换的

妙用 Looper 机制

我们可以利用 Looper 的机制来帮助我们做一些事情：

将 Runnable post 到主线程执行；
利用 Looper 判断当前线程是否是主线程。
完整示例代码如下：

public final class MainThread {

    private MainThread() {
    }

    private static final Handler HANDLER = new Handler(Looper.getMainLooper());

    public static void run(@NonNull Runnable runnable) {
        if (isMainThread()) {
            runnable.run();
        }else{
            HANDLER.post(runnable);
        }
    }

    public static boolean isMainThread() {
        return Looper.myLooper() == Looper.getMainLooper();
    }

}
能够省去不少样板代码。
先明确我们的问题：

Handler 是如何与线程关联的？
Handler 发出去的消息是谁管理的？
消息又是怎么回到 handleMessage() 方法的？
线程的切换是怎么回事？
回答：Handler 发送的消息由 MessageQueue 存储管理，并由 Loopler 负责回调消息到 handleMessage()。

线程的转换由 Looper 完成，handleMessage() 所在线程由 Looper.loop() 调用者所在线程决定。
*** 为什么在子线程中创建 Handler 会抛异常
- Handler 的工作是依赖于 Looper 的，而 Looper(与消息队列)又是属于某一 个线程(ThreadLocal 是线程内部的数据存储类，通过它可以在指定线程中存储 数据，其他线程则无法获取到)，其他线程不能访问。因此 Handler 就是间接 跟线程是绑定在一起了。因此要使用 Handler 必须要保证 Handler 所创建的线 程中有 Looper 对象并且启动循环。因为子线程中默认是没有 Looper 的，所以 会报错。 正确的使用方法是：
#+BEGIN_SRC java
public class WorkThread extends Thread {
    private Handler mHander;
    public Handler getHander() {
        return mHander;
    }
    public void quit() { // 这里是资源释放吗？
        mHander.getLooper().quit();
    }
    @Override
        public void run() {
        super.run();

        // 创建该线程对应的 Looper,
        // 内部实现
        //   1。new Looper()
        //   2。将 1 步中的 lopper 放在 ThreadLocal 里，ThreadLocal 是保存数据的， 主要应用场景是:线程间数据互不影响的情况
        //   3。在 1 步中的 Looper 的构造函数中 new MessageQueue();
        // 对消息机制不懂得同学可以查阅资料，网上很多也讲的很不错。
        Looper.myLooper(); // 一般是call Looper.prepare();吧，再查一下

        mHander = new Handler(){
            @SuppressLint("HandlerLeak")
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                Log.d("WorkThread", (Looper.getMainLooper() == Looper.myLooper()) + "," + msg.what);
            }
        };
        
        // 注意这 3 个的顺序不能颠倒
        Looper.loop();
    }
} 
#+END_SRC
*** Handler发送延时消息
- handler发送延时消息是通过postDelayed()方法将Runnanle对象封装成Message，然后调用sendMessageAtTime()，设置的时间是当时的时间+延时的时间。
- 发送延时消息实际上是往messageQueue中加入一条Message。
- Message在MessageQueue中实际是以单链表来存储的，且是按照时间顺序来插入的。时间顺序是以Message中的when属性来排序的。
- 重点：
  - postDelay并不是等待delayMillis延时时常后再加入消息队列，而是加入消息队列后阻塞(消息队列会按照阻塞时间排序)等待delayMillis后唤醒消息队列再执行。
  - sleep会阻塞线程
  - postDelayed不会阻塞线程
*** Handler线程间通信
- 作用：线程之间的消息通信
- 流程：主线程默认实现了Looper （调用loop.prepare方法 向sThreadLocal中set一个新的looper对象， looper构造方法中又创建了MsgQueue） 手动创建Handler ，调用 sendMessage 或者 post (runable) 发送Message 到 msgQueue ，如果没有Msg 这添加到表头，有数据则判断when时间 循环next 放到合适的 msg的next 后。Looper.loop不断轮训Msg，将msg取出 并分发到Handler 或者 post提交的 Runable 中处理，并重置Msg 状态位。回到主线程中 重写 Handler 的 handlerMessage 回调的msg 进行主线程绘制逻辑。
- 问题：
  - Handler 同步屏障机制：通过发送异步消息，在msg.next 中会优先处理异步消息，达到优先级的作用
  - Looper.loop 为什么不会卡死：为了app不挂掉，就要保证主线程一直运行存在，使用死循环代码阻塞在msgQueue.next()中的nativePollOnce()方法里 ，主线程就会挂起休眠释放cpu，线程就不会退出。Looper死循环之前，在ActivityThread.main()中就会创建一个 Binder 线程（ApplicationThread），接收系统服务AMS发送来的事件。当系统有消息产生（其实系统每 16ms 会发送一个刷新 UI 消息唤醒）会通过epoll机制 向pipe管道写端写入数据 就会发送消息给 looper 接收到消息后处理事件，保证主线程的一直存活。只有在主线程中处理超时才会让app崩溃 也就是ANR。
  - Messaage复用： 将使用完的Message清除附带的数据后, 添加到复用池中 ,当我们需要使用它时,直接在复用池中取出对象使用,而不需要重新new创建对象。复用池本质还是Message 为node 的单链表结构。所以推荐使用Message.obation获取 对象。

* AsyncTask
- 较为轻量级的异步类，封装了 FutureTask 的线程池、ArrayDeque 和 Handler 进行调度。AsyncTask 主要用于 _后台与界面持续交互_
- 我们来看看 AsyncTask 这个抽象类的定义，当我们定义一个类来继承 AsyncTask 这个类的时候，我们需要为其指定3个泛型参数：
#+BEGIN_SRC java
AsyncTask　<Params, Progress, Result>
#+END_SRC
  - Params: 这个泛型指定的是我们传递给异步任务执行时的参数的类型。
  - Progress: 这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。
  - Result: 这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。
- 我们在定义一个类继承 AsyncTask 类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则都将其写成 void。
- 我们来看一个官方给的例子：
#+BEGIN_SRC java
private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {
     protected Long doInBackground(URL... urls) {
         int count = urls.length;
         long totalSize = 0;
         for (int i = 0; i < count; i++) {
             totalSize += Downloader.downloadFile(urls[i]);
             publishProgress((int) ((i / (float) count) * 100));
             // Escape early if cancel() is called
             if (isCancelled()) break;
         }
         return totalSize;
     }
     protected void onProgressUpdate(Integer... progress) {
         setProgressPercent(progress[0]);
     }
     protected void onPostExecute(Long result) {
         showDialog("Downloaded " + result + " bytes");
     }
}
#+END_SRC
- 使用时只需要集成 AsyncTask，创建对象并调用 execute 执行即可：
#+BEGIN_SRC java
new DownloadFilesTask().execute(url1, url2, url3);
#+END_SRC
- doInBackground(Params…) 方法里执行耗时逻辑，然后在 onPostExecute(Result) 中将结果更新回UI组件
- AsyncTask 的几个主要方法中，doInBackground 方法运行在子线程，execute、onPreExecute、onProgressUpdate、onPostExecute 这几个方法都是在 UI 线程运行的。
** 使用 AsyncTask 的注意事项
- AsyncTask 的实例必须在 UI Thread 中创建。
- 只能在 UI 线程中调用 AsyncTask 的 execute 方法。
- AsyncTask 被重写的四个方法是系统自动调用的,不应手动调用。
- 每个AsyncTask 只能被执行一次，多次执行会引发异常。
- AsyncTask 的四个方法，只有 doInBackground 方法是运行在其他线程中,其他三个方法都运行在 UI 线程中，也就说其他三个方法都可以进行 UI 的更新操作。
- AsyncTask 默认是串行执行，如果需要并行执行，使用接口 executeOnExecutor 方法。
** 优点：
- 结构清晰，使用简单，适合后台任务的交互。
- 异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与 UI 线程抢占资源。
** 缺点：
- 结构略复杂，代码较多。
- 每个 AsyncTask 只能被执行一次，多次调用会发生异常。
- AsyncTask 在整个 Android 系统中维护一个线程池，有可能被其他进程的任务抢占而降低效率。

* HandlerThread
- HandlerThread 是一个自带 Looper 消息循环的线程类。处理异步任务的方式和 Thread + Looper + Handler 方式相同。
** 优点：
- 简单，内部实现了普通线程的 Looper 消息循环。
- 可以串行执行多个任务。
- 内部拥有自己的消息队列，不会阻塞 UI 线程。
** 缺点：
- 没有结果返回接口，需要自行处理。
- 消息过多时，容易造成阻塞。
- 只有一个线程处理，效率较低。
- 线程优先级默认优先级为 THREAD_PRIORITY_DEFAULT，容易和 UI 线程抢占资源。

*  IntentService
- IntentService 继承自 Service 类，用于启动一个异步服务任务，它的内部是通过 HandlerThread 来实现异步处理任务的。
- 我们来看下 IntentService 的主要方法：
#+BEGIN_SRC java
// mServiceLooper;
// mServiceHandler;
@Override
public void onCreate() {
    // TODO: It would be nice to have an option to hold a partial wakelock during processing,
    // and to have a static startService(Context, Intent) method that would launch the service & hand off a wakelock.
    super.onCreate();
    HandlerThread thread = new HandlerThread("IntentService [" + mName + "]");
    thread.start();
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
}
@Override
public void onStart(@Nullable Intent intent, int startId) {
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    msg.obj = intent;
    mServiceHandler.sendMessage(msg);
}
private final class ServiceHandler extends Handler {
    public ServiceHandler(Looper looper) {
        super(looper);
    }
    @Override
        public void handleMessage(Message msg) {
        onHandleIntent((Intent)msg.obj);
        stopSelf(msg.arg1);
    }
}
#+END_SRC
** 优点：
- 只需要继承 IntentService，就可以在 onHandlerIntent 方法中异步处理 Intent 类型任务了。
- 任务结束后 IntentService 会自行停止，无需手动调用 stopService。
- 可以执行处理多个 Intent 请求，顺序执行多任务。
- IntentService 是继承自 Service，具有后台 Service 的优先级。
** 缺点：
- 需要启动服务来执行异步任务，不适合简单任务处理。
- 异步任务是由 HandlerThread 实现的，只能单线程、顺序处理任务。
- 没有返回 UI 线程的接口。

* 使用线程池来处理异步任务
- 利用 Executors 的静态方法 newCachedThreadPool()、newFixedThreadPool()、newSingleThreadExecutor() 及重载形式实例化 ExecutorService 接口即得到线程池对象。
- 动态线程池 newCachedThreadPool()：根据需求创建新线程的，需求多时，创建的就多，需求少时，JVM 自己会慢慢的释放掉多余的线程。
- 固定数量的线程池 newFixedThreadPool()：内部有个任务阻塞队列，假设线程池里有2个线程，提交了4个任务，那么后两个任务就放在任务阻塞队列了，即使前2个任务 sleep 或者堵塞了，也不会执行后两个任务，除非前2个任务有执行完的。
- 单线程 newSingleThreadExecutor()：单线程的线程池，这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。
** 优点：
- 线程的创建和销毁由线程池来维护，实现了线程的复用，从而减少了线程创建和销毁的开销。
- 适合执行大量异步任务，提高性能。
- 灵活性高，可以自由控制线程数量。
- 扩展性好，可以根据实际需要进行扩展。
** 缺点：
- 代码略显复杂。
- 线程池本身对系统资源有一定消耗。
- 当线程数过多时，线程之间的切换成本会有很大开销，从而使性能严重下降。
- 每个线程都会耗费至少 1040KB 内存，线程池的线程数量需要控制在一定范围内。
- 线程的优先级具有继承性，如果在 UI 线程中创建线程池，线程的默认优先级会和 UI 线程相同，从而对 UI 线程使用资源进行抢占。


* Java基础之多线程(没那么复杂)
** 多线程的引入
- 1.什么是多线程
  - 线程是程序执行的一条路径，一个进程中可以包含多条线程;多线程并发执行可以提高程序的效率
- 2.进程和线程之间的关系
  - 操作系统可以同时执行多个任务，每个任务就是进程;进程可以同时执行多个任务，每个任务就是线程。
- 3.多线程的应用场景
  - 红蜘蛛同时共享屏幕给多个电脑
  - 迅雷开启多条线程一起下载
  - QQ开启多人聊天
  - 服务器同时处理多个客户的请求
- 多线程并行和并发的区别
  - 并行性和并发性是两个概念，并行性指在同一时刻，有多条指令在多个处理器上同时执行
  - 并发性指的是同一时刻只有一条指令被执行，但多个进程指令被快速切换执行是的在宏观上具有多个进程被同时执行的效果
- Java程序运行原理和JVM的启动是多线程的吗？
  - java程序运行原理
  - Java命令启动jvm，启动jvm等于启动一个应用程序，也就是启动了一个进程，该进程会自动启动一个“主线程”，然后主线程去调用某个类的main方法
  - Jvm启动是多线程的的吗
  - JVM启动至少启动了垃圾回收线程和主线程，所以是多线程
** 多线程的实现方式
*** 1. 继承Thread类创建线程类
- (1) 定义Thread的子类，并重写该类的run方法，该ru的执行体就代表了线程需要完成的任务，因此run()方法被称为线程执行体
- (2) 创建Thread子类的实例，即创建了线程对象
- (3) 调用线程对象的start()方法启动该线程
#+BEGIN_SRC java
public class Demo1__Thread {
    public static void main(String[] args) {
        ChThread t=new ChThread();
        t.start();
        for(int i=0;i<1000;i++) {
            System.out.println("我是主方法！");
        }
    }
}
 class ChThread extends Thread {
    @Override
    public void run() {
        super.run();
        for(int i=0;i<1000;i++) {
            System.out.println("我是run方法");
        }
    }
 }
#+END_SRC 
- 上述代码的执行验证了多线程，如果上述程序的执行过程是多线程的话，会发现屏幕中的 ”我是主方法”和“我是run方法” 的字样是交替出现的，这说明了程序的的执行过程为并行执行Thread类的Start()方法启动run()方法的线程，和主方法中的执行同时进行。
*** 2.实现Runnable接口创建线程类
- (1) 定义一个实现了Runnable接口的实现类(2) 创建Runnable实现类的实例(3) 将创建的实例作为Thread类的target类创建Thread对象，该对象才是真正的线程对象 (4) 用创建的Thread对象启动线程
#+BEGIN_SRC java
public class tmp implements Runnable { // Thread_Running
    private int i;
    public void run() {
        for(;i < 15;i++) 
            System.out.println(Thread.currentThread().getName()+"  "+i);
    }
    public static void main(String[] args) {
        for(int i = 0;i < 15;i++) {
            System.out.println(Thread.currentThread().getName()+"  "+i);
            if(i == 7) {
                new Thread(new tmp(),"thread 1").start();
                new Thread(new tmp(),"thread 2").start();
            }
        }
    }
}
#+END_SRC 
- 执行的结果如下
#+BEGIN_SRC kotlin
main  0
main  1
main  2
main  3
main  4
main  5
main  6
thread 1  0
thread 1  1
thread 1  2
thread 1  3
thread 1  4
thread 1  5
thread 2  0
thread 2  1
thread 2  2
thread 2  3
thread 2  4
thread 2  5
thread 2  6
thread 2  7
thread 2  8
thread 2  9
thread 2  10
thread 2  11
thread 2  12
thread 2  13
thread 2  14
main  7
thread 1  6
main  8
thread 1  7
main  9
thread 1  8
thread 1  9
thread 1  10
main  10
thread 1  11
thread 1  12
thread 1  13
thread 1  14
main  11
main  12
main  13
main  14
#+END_SRC
- 查看API文档，会发现Runnable接口只定义了run()方法这一个抽象类，所以实现Runnable接口的实现类只有run()方法，仅作为线程执行体，所以，Runnable对象仅仅作为Thread对象的target，而实际的线程对象依然是Thread实例，Thread实例负责执行target的run()方法。
*** 3.实现Callable接口和Future接口创建多线程(Callable接口和FutureTask还有点儿生)
- （1）Callable接口更像是Runnable接口的增强版，相比较Runable接口,Call()方法新增捕获和抛出异常的功能;Call()方法可以返回值
- （2）Future接口提供了一个实现类FutureTask实现类，FutureTaks类用来保存Call()方法的返回值，并作为Thread类的target。
- （3）调用FutureTask的get()方法来获取返回值
#+BEGIN_SRC java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
/**
 * (1)创建Callable接口的实现类，并重写call()方法,该call()方法作为线程的执行体，且有返回值
 * (2)创建了Callable接口的实现类的实例，并用FutureTask()方法包装对象，该FutureTask()对象实现了
 *    将对象的返回值包装的功能
 * (3)使用FutureTask对象将Thread对象的target，创建并启动线程
 * (4)调用FutureTask对象的get()方法获得子线程执行结束后的返回值
 * */
public class tmp implements Callable < Integer> {    // tmp: Callable_Future
    @Override
        public Integer call() throws Exception {   // 重写Callable接口中的call()方法
        int i = 0; 
        for(; i < 20; i++) 
            System.out.println(Thread.currentThread().getName()+" "+i); 
        return i; 
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        // 创建Callable的对象
        tmp ca = new tmp(); 
        FutureTask < Integer> ft = new FutureTask < Integer>(ca); 
        for(int i = 0; i < 20; i++) {
            // 返回值主线程的名称和执行代号
            System.out.println(Thread.currentThread().getName()+" "+i);   
            if (i == 7) {
                new Thread(ft, "Callable thread").start(); 
                // 该方法将导致主线程被阻塞，直到call()方法结束并返回为止
                // System.out.println("子线程的返回值"+ft.get());   
            }
        }
        try {
            System.out.println("sub thread return value: "+ft.get()); 
        } catch (Exception e) {
            e.printStackTrace(); 
        }
    }
}
#+END_SRC 
- 上面的程序中，FutufeTask方法的get()方法将获得Call()方法的返回值，但是该方法将导致主线程受阻直到Call()方法结束并返回为止。
- 打印结果如下： 
#+BEGIN_SRC kotlin
main 0
main 1
main 2
main 3
main 4
main 5
main 6
main 7
main 8
main 9
main 10
main 11
main 12
main 13
Callable thread 0
main 14
Callable thread 1
main 15
Callable thread 2
main 16
Callable thread 3
main 17
main 18
main 19
Callable thread 4
Callable thread 5
Callable thread 6
Callable thread 7
Callable thread 8
Callable thread 9
Callable thread 10
Callable thread 11
Callable thread 12
Callable thread 13
Callable thread 14
Callable thread 15
Callable thread 16
Callable thread 17
Callable thread 18
Callable thread 19
sub thread return value: 20
#+END_SRC
*** 4.三种实现多线程的方式对比
|------------------+----------+--------------------+--------------------------------------------+--------------------------------------------|
| 实现方式         | 重写方法 | 启动线程的方式     | 优点                                       | 缺点                                       |
|------------------+----------+--------------------+--------------------------------------------+--------------------------------------------|
| 继承Thread类     | run()    | Thread对象.start() | 编程简单，直接用this即可获取当前对象       | 继承Thread的子类不能继承其他的类           |
|------------------+----------+--------------------+--------------------------------------------+--------------------------------------------|
| 实现Runnable接口 | run()    | Thread对象.start() | 1.实现类可以继承其他类<br>                 | 编程复杂，                                 |
|                  |          |                    | 2.多个对象共享一个target，形成了清晰的模型 | 必须使用Thread.currentThread()返回当前对象 |
|------------------+----------+--------------------+--------------------------------------------+--------------------------------------------|
| 实现Callable接口 | Call()   | Thread对象.start() | 1.同Runnable接口<br>                       | 同Runnable接口                             |
|                  |          |                    | 2.Call()方法有返回值并能抛出异常           |                                            |
|------------------+----------+--------------------+--------------------------------------------+--------------------------------------------|
- 通过上面的对比发现，一般在项目中，我们使用Runnable接或者Callable接口来实现多线程。
*** 5.线程的生命周期
- 1.线程并不是创建过之后就开始执行的，也不是一直处于执行状态，一个线程的生命周期一个又五个：新建、就绪、运行、阻塞、死亡。
- 2.线程的这五种状态的原理参照《计算机组成原理2》多线程部分
*** 6.控制线程
**** 1.join线程
- 1.Thread类中的成员方法，让调用join()方法的线程处于等待状态，直到子线程执行结束<br>2.join()方法通常由使用线程的程序调用，用于将一个线程拆分成若干小的线程执行，执行结束最后由主线程进行进一步的操作
#+BEGIN_SRC java
public class tmp extends Thread { // tmp: tmp
    // 创建一个有参构造函数，用来为线程命名
    public tmp(String str) {
        super(str); 
    } 
    // 重写run方法
    public void run() {
        for(int i = 1; i < 20; i++) {
            System.out.println(getName()+" "+i); 
        }
    }
    public static void main(String[] args)throws Exception {
        // 启动子线程
        new tmp("Sub thread").start(); 
        for(int i = 0; i < 20; i++) {
            if(i == 7) {
                tmp jt = new tmp("new thread's sub thread"); 
                jt.start();  // 启动子线程
                jt.join();   // 让主线程处于等待状态
            }
            System.out.println(Thread.currentThread().getName()+" "+i); 
        }
    }
}
#+END_SRC 
- mian线程调用join之后，出去阻塞状态，两个子线程并发执行。直到两个子程序执行结束之后，main线程才开始执行。
- join()线程有如下三种重载形式
  - 1.join() :
  - 2.join(long millis) :被join的线程的时间最长为millis毫秒，如果超过了这个millis则线程不被执行
  - 3.join(long millis,int nanos) :被join的线程的时间最长为millis毫秒+nanos微秒，如果超过了这个时间则线程不被执行 第三种重载行驶一般用不到，因为无论是计算机系统还是计算机硬件，还没发精确到微秒
- 打印结果如下：
#+BEGIN_SRC kotlin
main 0
main 1
main 2
main 3
main 4
main 5
main 6
Sub thread 1
Sub thread 2
Sub thread 3
new thread's sub thread 1
new thread's sub thread 2
Sub thread 4
new thread's sub thread 3
new thread's sub thread 4
Sub thread 5
new thread's sub thread 5
Sub thread 6
new thread's sub thread 6
Sub thread 7
new thread's sub thread 7
Sub thread 8
new thread's sub thread 8
Sub thread 9
new thread's sub thread 9
Sub thread 10
new thread's sub thread 10
Sub thread 11
new thread's sub thread 11
Sub thread 12
new thread's sub thread 12
Sub thread 13
new thread's sub thread 13
Sub thread 14
new thread's sub thread 14
Sub thread 15
new thread's sub thread 15
Sub thread 16
new thread's sub thread 16
Sub thread 17
new thread's sub thread 17
Sub thread 18
new thread's sub thread 18
Sub thread 19
new thread's sub thread 19
main 7
main 8
main 9
main 10
main 11
main 12
main 13
main 14
main 15
main 16
main 17
main 18
main 19
#+END_SRC
**** 2.后台线程
- 后台线程运行于后台，任务是为其他线程提供服务，也被称为“守护线程”或“精灵线程”。JVM的垃圾回收机制就是一个典型的后台线程。<br> 通过调用Thread类的setDaemon(true)方法将线程设置为后台线程
#+BEGIN_SRC java
public class tmp extends Thread { // DaemonThread
    @Override
        public void run() {
        for(int i = 0; i < 2000; i++) {
            System.out.println(getName()+" "+i); 
        }
    }
    public static void main(String[] args) {
        tmp dt = new tmp(); 
        dt.setDaemon(true); 
        dt.start(); 
        for(int i = 0; i < 7; i++) {
            System.out.println(Thread.currentThread().getName()+" "+i);  // 主线程： 10 个
        }
    }
}
#+END_SRC 
- 运行结果：
#+BEGIN_SRC kotlin
Thread-0 0
Thread-0 1
Thread-0 2
main 0
Thread-0 3
main 1
main 2
main 3
main 4
main 5
main 6
Thread-0 4
Thread-0 5
Thread-0 6
#+END_SRC
- 1.Thread-0的后台进程本该当i=999的时候才停止进行，但是程序中只进行到114次，这是因为所有的前台进程结束之后，后天进程的存在也就是去了意义，所以后台进程也跟着死亡。
- 2.前台线程死亡之后，JVM会通知后台线程死亡，但是从后台线程接收指令到做出反应需要一定的时间，这就是为什么上述程序中的后台进程在main线程死亡之后后台进程还进行到114的原因。
**** 3.线程睡眠
- 如果需要线程停顿一段时间进入阻塞状态，可以调用Thread类的静态方法sleep()，sleep（）有两种重载形式
  - sleep(long millis)
    - 让当前正在执行的线程暂停mili毫秒，进入阻塞状态。该方法受到系统计时器和线程调度器精度的影响。
  - sleep(long millis,int nanos)
    - 让当前正在执行的线程暂停milis毫秒+nanos微秒，进入阻塞状态。该方法受到系统计时器和线程调度器精度的影响（不常用）
#+BEGIN_SRC java
public class tmp { // SleepThread
    public static void main(String[] args) throws Exception {
        for(int i = 0; i < 7; i++) {
            System.out.println(Thread.currentThread().getName()+" "+i); 
            Thread.sleep(2000); 
        }
    }
}
#+END_SRC (
- 观察程序想运行过程会发现，每一个进程(_进程_ ？)之间相隔1秒。
**** 4.线程让步
- 调用Thrad类的静态方法 yield()方法可以实现线程让步，和sleep()方法类似，yield()方法也是让当前正在运行的线程暂停，但是不会使线程阻塞，而是让线程进入就绪状态，让线程调度器重新安排一次线程调度，完全有可能出现的状况是，刚刚调用yield()方法进入就绪状态的线程就被线程调度器重新调度出来重新执行。
#+BEGIN_SRC java
public class tmp extends Thread { // YieldThread
    public tmp(String str) {
        super(str); 
    } 
    @Override
        public void run() {
        // TODO Auto-generated method stub
        for (int i = 0; i < 12; i++) {
            System.out.println(getName()+" "+i); 
            if (i == 7) 
                Thread.yield();                   // 线程让步
        }
    }
    public static void main(String[] args) {
        tmp yt1 = new tmp("Adv"); 
        yt1.setPriority(MAX_PRIORITY);            // 将次线程设置成最高优先级
        yt1.start();                              // 启动线程
        tmp yt2 = new tmp("Base"); 
        yt2.setPriority(MIN_PRIORITY); 
        yt2.start(); 
    }
}
#+END_SRC 
- 1.线程调用yield()方法后将执行的机会让给优先级相同的线程<br>2.高优先级的线程调用yield()方法暂停之后，系统中没有与之相同优先级和更高的优先级的线程，则线程调度器会将该线程重新调度出来，重新执行。
- sleep()方法和yield()方法比较
|---------+------------------------------------------------------------+----------+-------------------------+----------|
| 方法    | 执行机会                                                   | 线程状态 | 是否抛出异常            | 可移植性 |
|---------+------------------------------------------------------------+----------+-------------------------+----------|
| sleep() | 线程暂停之后，会给其他线程执行的机会，不用理会线程的优先级 | 阻塞状态 | InterruptedExextion异常 | 优       |
| yield() | 线程暂停之后，只会给优先级相同或更高优先级的线程执行的机会 | 就绪状态 | 否                      | 差       |
|---------+------------------------------------------------------------+----------+-------------------------+----------|
- 打印结果： 
#+BEGIN_SRC kotlin
Base 0
Base 1
Base 2
Base 3
Base 4
Base 5
Base 6
Base 7
Adv 0
Adv 1
Adv 2
Adv 3
Base 8
Adv 4
Base 9
Adv 5
Base 10
Adv 6
Base 11
Adv 7
Adv 8
Adv 9
Adv 10
Adv 11
#+END_SRC
**** 5.改变线程优先级
- 1.一般线程具有优先级，更高优先级的线程比优先级低的线程能获得更多的执行机会
- 2.每个线程默认的优先级和创建他们的父线程的优先级相同。 
- 3.Thread类提供了setPriorit(int newPriority)、getPriority() 方法来设置和获取线程的优先级4.也可以使用Thread类的3个静态常量来设置线程的优先级

* 两种线程池：THREAD_POOL_EXECUTOR和SERIAL_EXECUTOR
- 线程池是管理异步任务AsyncTask所创建的队列，系统提供了两个线程池：THREAD_POOL_EXECUTOR 和 SERIAL_EXECUTOR
  - 当一个AsyncTask执行execute()方法时，默认被加入SERIAL_EXECUTOR中，等待执行。SERIAL_EXECUTOR中的任务按照“先进先执行，依次执行”的原则，后续任务要等先前的任务执行完毕后才会执行，顺次执行。
  - 而另一种线程池THREAD_POOL_EXECUTOR则不同，被加入线程池的任务会立刻执行，也就是所有任务并发执行。但是有个前提，如果THREAD_POOL_EXECUTOR中一起执行的任务超过了5个，那么新加入的任务会等这五个中有线程执行完毕了再执行。(这里再查验证一下，与他给出的代码不符合)
- 使用AsyncTask.executeOnExecutor()来指定使用哪个线程池来管理AsyncTask
#+BEGIN_SRC java
DownloadTask task = new DownloadTask(m_progressBar[m_prgBarIndex++], MainActivity.this);
m_taskList.add(task);
task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "westworld");
#+END_SRC 


